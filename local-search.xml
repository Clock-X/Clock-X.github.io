<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ECC</title>
    <link href="/2021/03/31/ECC/"/>
    <url>/2021/03/31/ECC/</url>
    
    <content type="html"><![CDATA[<h1 id="ECC椭圆加密曲线"><a href="#ECC椭圆加密曲线" class="headerlink" title="ECC椭圆加密曲线"></a>ECC椭圆加密曲线</h1><h2 id="椭圆曲线的定义"><a href="#椭圆曲线的定义" class="headerlink" title="椭圆曲线的定义"></a>椭圆曲线的定义</h2><p>Z<sub>p</sub>(p&gt;3)上的椭圆曲线指满足以下条件的所有对(x,y) ∈ Z<sub>p</sub> 的集合：</p><p>​                y<sup>2</sup> ≡ x<sup>3</sup> + a*x + b mod p</p><p>以及一个无穷大的虚数点此处记为G，其中（a,b）∈ Z<sub>p</sub></p><p>且满足条件4*a<sup>3</sup> + 27*b<sup>2</sup> ≠ 0 mod p。</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210331001025785.png" alt="image-20210331001025785"></p><h2 id="椭圆曲线上的群操作"><a href="#椭圆曲线上的群操作" class="headerlink" title="椭圆曲线上的群操作"></a>椭圆曲线上的群操作</h2><p>可以用加法符号”+“来表示群操作，两点相“加”得到第三点</p><p>P + Q =R</p><p>即(x<sub>1</sub> , y<sub>1</sub> ) + (x<sub>2</sub> , y<sub>2</sub>) = (x<sub>3</sub> , y<sub>3</sub>)</p><p>两点相“加”的方式与这两点是否是相同点有关</p><h4 id="相异点连线的交点并关于X轴对称的点即为得到的点："><a href="#相异点连线的交点并关于X轴对称的点即为得到的点：" class="headerlink" title="相异点连线的交点并关于X轴对称的点即为得到的点："></a>相异点连线的交点并关于X轴对称的点即为得到的点：</h4><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210331001246350.png" alt="image-20210331001246350"></p><h4 id="相同点切线的交点取对称："><a href="#相同点切线的交点取对称：" class="headerlink" title="相同点切线的交点取对称："></a>相同点切线的交点取对称：</h4><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210331001501795.png" alt="image-20210331001501795"></p><p>其坐标点的关系：</p><p>$$<br>x_3 = s^2 - x_1 -x_2;mod;p\<br>y_3 = s(x_1 - x_3) - y_1;mod;p\<br>;\<br>其中s的值会因情况不同而变化\<br>;\<br>s=\left {<br>\begin{array}{c}<br>\frac {y_2 - y_1}{x_2 - x_1};mod;p;;;P≠Q\<br>\frac{3x^2_1 + a}{2y_1};mod;p;;P=Q<br>\end{array}<br>\right.<br>$$<br>注意：P + G =P    P + (-P) = G </p><p>P(x<sub>p</sub> , y<sub>p</sub>)的逆元为-P(x<sub>p</sub> , -y<sub>p</sub>)，若在素数域上，则-P(x<sub>p</sub> , P-y<sub>p</sub>)</p><p>对于椭圆加密曲线的群操作，相当于把以前的群的数字变成了坐标点，群操作也只是变得稍微抽象了一些。</p><p>所以同样的，曲线上的点可以与G一起构成循环子群</p><p>假如一个群的阶数为X，那么X*P = G，（X+1）* P = P</p><p>相当于把之前的群的知识类比过来。</p><h4 id="自然而然我们就可以构建出基于椭圆曲线的离散对数问题："><a href="#自然而然我们就可以构建出基于椭圆曲线的离散对数问题：" class="headerlink" title="自然而然我们就可以构建出基于椭圆曲线的离散对数问题："></a>自然而然我们就可以构建出基于椭圆曲线的离散对数问题：</h4><h4 id="P-P-…-P-d-P-T"><a href="#P-P-…-P-d-P-T" class="headerlink" title="P + P + … +P = d*P =T"></a>P + P + … +P = d*P =T</h4><p>有了基于椭圆曲线的离散对数问题，我们自然也可以得到基于椭圆曲线的密钥交换：</p><h4 id="基于椭圆加密曲线的密钥交换"><a href="#基于椭圆加密曲线的密钥交换" class="headerlink" title="基于椭圆加密曲线的密钥交换"></a>基于椭圆加密曲线的密钥交换</h4><h5 id="ECDH域参数选取："><a href="#ECDH域参数选取：" class="headerlink" title="ECDH域参数选取："></a>ECDH域参数选取：</h5><p>1.素数p和椭圆曲线：</p><p>​                y<sup>2</sup> ≡ x<sup>3</sup> + a*x + b mod p</p><p>2.本原元P = (x<sub>p</sub> , y<sub>p</sub>) (此点可循环生成所有点)</p><h5 id="椭圆曲线-Diffie-Hellman-密钥交换（ECDH）："><a href="#椭圆曲线-Diffie-Hellman-密钥交换（ECDH）：" class="headerlink" title="椭圆曲线 Diffie-Hellman 密钥交换（ECDH）："></a>椭圆曲线 Diffie-Hellman 密钥交换（ECDH）：</h5><p>Alice:                                                                                       Bob:</p><p>选择k<sub>prA</sub> = a ∈ {2,3,…,#E-1}                             选择k<sub>prB</sub> = b ∈ {2,3,…,#E-1}</p><p>计算k<sub>pubA</sub> =aP =A = (x<sub>A</sub> , y<sub>A</sub>)                              计算k<sub>pubB</sub> = bP =B ∈(x<sub>B</sub> , y<sub>B</sub>)</p><p>​                                             A———–&gt;</p><p>​                                             &lt;————B</p><p>而后两人分别计算aB = T<sub>AB</sub>    ,    bA = T<sub>AB</sub></p><p>就得到了联合密钥：T（x<sub>AB</sub> , y<sub>AB</sub>）</p>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ECC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LFSR</title>
    <link href="/2021/03/31/LFSR/"/>
    <url>/2021/03/31/LFSR/</url>
    
    <content type="html"><![CDATA[<h1 id="lfsr-线性反馈位移器-小结"><a href="#lfsr-线性反馈位移器-小结" class="headerlink" title="lfsr(线性反馈位移器)小结"></a>lfsr(线性反馈位移器)小结</h1><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210330203704719.png" alt="image-20210330203704719"></p><p>如图，lfsr拥有m个触发器和m个可能的反馈位置，系数p<sub>i</sub>即反馈系数，s<sub>i</sub>与p<sub>i</sub>异或后（此处为一一对应异或），得到的一串新的序列，这一串序列再一一异或过去得到新的值也就是s<sub>m</sub>,同时s<sub>0</sub>会被输出，s<sub>m</sub>会接替s<sub>m-1</sub>的位置，整个序列相当于向前移了一个位置。</p><p>（感觉这样说不是很清楚，还是上公式吧）</p><p>s<sub>m</sub> ≡ s<sub>m-1</sub>p<sub>m-1</sub> + … + s<sub>1</sub>p<sub>1</sub> + s<sub>0</sub>p<sub>0</sub> mod 2(s<sub>m</sub> = s<sub>m-1</sub>p<sub>m-1</sub> ⊕ …  ⊕ s<sub>1</sub>p<sub>1</sub> ⊕ s<sub>0</sub>p<sub>0</sub>)</p><p>第m个元素会由此计算得出，第m+1个元素也很容易就可以推导出来：</p><p>s<sub>m+1</sub> ≡ s<sub>m</sub>p<sub>m-1</sub> + … + s<sub>2</sub>p<sub>1</sub> + s<sub>1</sub>p<sub>0</sub> mod 2</p><p>m个触发器中的值会随着时间不断变化，但反馈系数不变，且新的值往往由之前的值决定。通过初始序列计算后来的序列自然是完全可以的，而通过后来的序列推算之前的序列也是可以的（如果知道反馈系数）</p><p>但即便不知道反馈系数，在特定条件下也可以进行攻击。</p><p>针对单个lfsr的已知明文攻击：</p><p>假设有明文x<sub>0</sub>,x<sub>1</sub>,…,x<sub>2m-1</sub>,及其对应密文y<sub>0</sub>,y<sub>1</sub>,…,y<sub>2m-1</sub>。我们便可以构造出初试的2m个序列：</p><p>s<sub>i</sub> ≡ x<sub>i</sub> + y<sub>i</sub> mod 2 ;  i=0,1,…,2m-1。</p><p>当我们拥有了2m个序列时，便可以很轻松地推出密钥k(即p<sub>i</sub>),s<sub>m</sub>由前m-1序列与k分别异或后再逐个异或而来，s<sub>m+1</sub>同理，由此我们可以得到m个方程，未知数也是m个：</p><p>i=0,    s<sub>m</sub> ≡ s<sub>m-1</sub>p<sub>m-1</sub> + … + s<sub>1</sub>p<sub>1</sub> + s<sub>0</sub>p<sub>0</sub>    mod 2</p><p>i=1,    s<sub>m+1</sub> ≡ s<sub>m</sub>p<sub>m-1</sub> + … + s<sub>2</sub>p<sub>1</sub> + s<sub>1</sub>p<sub>0</sub>    mod 2</p><p>…  ,                    ……                                        …</p><p>i=m-1, s<sub>2m-1</sub> ≡ s<sub>2m-2</sub>p<sub>m-1</sub> + … + p<sub>1</sub>s<sub>m</sub> + p<sub>0</sub>s<sub>m-1</sub>    mod2</p><p>就可以解出p<sub>i</sub> 了。</p><p>这样看来lfsr是极易受到攻击的，所以我们往往组合使用。</p><h2 id="Trivium"><a href="#Trivium" class="headerlink" title="Trivium"></a>Trivium</h2><p>将三个位移寄存器结合使用，并借助AND操作提高了安全性。</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210330213351934.png" alt="image-20210330213351934"></p><p>A位移反馈器长度为93，除去正常的位移器运行，69位会作为反馈为影响输入，66位则作为前馈位影响输出，同时91,92位进行AND操作与前馈位一起影响输出，而A的输出会作为B的输入的一部分，B的输出又会作为C的输入，而C的输出又将作为影响A的输入的一部分，而我们得到的密钥序列是A,B,C三个位移器的输出的异或值。</p><p>使用Trivium进行加密：</p><p>1.初始化阶段：将80位的iv加载至A,B最左边，C最右边3位为1，剩余都设置为0.</p><p>2.热身阶段：计时 4*288 = 1152次，并不输出。</p><p>3.加密阶段：至此开始产生的位构成密钥序列。</p><p>（热身阶段是为了充分随机化密码，确保密钥序列同时取决于密钥k和iv）</p>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -LFSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021hgame_aes_and_DH</title>
    <link href="/2021/03/19/hgame_aes_and_differ-hellman/"/>
    <url>/2021/03/19/hgame_aes_and_differ-hellman/</url>
    
    <content type="html"><![CDATA[<p>出现了g**a mod p和g**b mod p,可以猜到是</p><p>Differ-Hellman密钥交换，</p><p>即真正的密钥是g**ab mod p,但因为a,b未知，所以要把a,b求出</p><p>正常情况下是要求离散对数的，但因为对话中有提示是在加法群下操作的，</p><p>而在加法群中，幂即重复调用改群的运算，即g**a mod p是a*g mod p</p><p>又因为A = a*g mod p所以a=A*g<sup>-1</sup> mod p(g<sup>-1</sup>是g对p的逆元)，同理可以得到b的值，从而得到密钥的值。</p><p>之后直接解AES即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> a2b_hex<br>A = <span class="hljs-number">6407001517522031755461029087358686699246016691953286745456203144289666065160284103094131027888246726980488732095429549592118968601737506427099198442788626223019135982124788211819831979642738635150279126917220901861977041911299607913392143290015904211117118451848822390856596017775995010697100627886929406512483565105588306151304249791558742229557096175320767054998573953728418896571838697779621641522372719890056962681223595931519174265357487072296679757688238385898442549594049002467756836225770565740860731932911280385359763772064721179733418453824127593878917184915316616399071722555609838785743384947882543058635</span><br>B = <span class="hljs-number">5522084830673448802472379641008428434072040852768290130448235845195771339187395942646105104638930576247008845820145438300060808178610210847444428530002142556272450436372497461222761977462182452947513887074829637667167313239798703720635138224358712513217604569884276513251617003838008296082768599917178457307640326380587295666291524388123169244965414927588882003753247085026455845320527874258783530744522455308596065597902210653744845305271468086224187208396213207085588031362747352905905343508092625379341493584570041786625506585600322965052668481899375651376670219908567608009443985857358126335247278232020255467723</span><br>p = <span class="hljs-number">30567260905179651419358486099834315837354102714690253338851161207042846254351374572818884286661092938876675032728700590336029243619773064402923830209873155153338320502164587381848849791304214084993139233581072431814555885408821184652544361671134564827265516331283076223247829980225591857643487356406284913560960657053777612115591241983729716542192518684003840806442329098770424504275465756739925434019460351138273272559738332984560095465809481270198689251655392941966835733947437503158486731906649716026200661065054914445245468517406404904444261196826370252359102324767986314473183183059212009545789665906197844518119</span><br>g = <span class="hljs-number">12602983924735419868428783329859102652072837431735895060811258460532600319539509800915989811879506790207025505003183121812480524033163157114086741486989697</span><br>x1 = gp.invert(g,p)*A%p<br>x2 = gp.invert(g,p)*B%p<br>key1 = x1*x2*g%p<br>shared_secret = key1<br>sha1 = hashlib.sha1()<br>sha1.update(<span class="hljs-built_in">str</span>(shared_secret).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>key = sha1.digest()[:<span class="hljs-number">16</span>]<br>iv1 = a2b_hex(<span class="hljs-string">&#x27;d3811beb5cd2a4e1e778207ab541082b&#x27;</span>)<br>iv2= a2b_hex(<span class="hljs-string">&#x27;b4259ed79d050dabc7eab0c77590a6d0&#x27;</span>)<br>data1 = a2b_hex(<span class="hljs-string">&#x27;059e9c216bcc14e5d6901bcf651bee361d9fe42f225bc0539935671926e6c092&#x27;</span>)<br>data2 = a2b_hex(<span class="hljs-string">&#x27;af3fe410a6927cc227051f587a76132d668187e0de5ebf0608598a870a4bbc89&#x27;</span>)<br>decrypt1 = AES.new(key,AES.MODE_CBC,iv1)<br>decrypt2 = AES.new(key,AES.MODE_CBC,iv2)<br>flag1 = decrypt1.decrypt(data1)<br>flag2 = decrypt2.decrypt(data2)<br>print(flag1,flag2)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ctf -DH -aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rsa初期</title>
    <link href="/2021/03/19/RSA%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%EF%BC%88%E5%88%9D%E6%9C%9F%EF%BC%89/"/>
    <url>/2021/03/19/RSA%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%EF%BC%88%E5%88%9D%E6%9C%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA常见题型"><a href="#RSA常见题型" class="headerlink" title="RSA常见题型"></a>RSA常见题型</h1><h2 id="一、普通解密-给出e-c，且已知p-q或较易分解的n"><a href="#一、普通解密-给出e-c，且已知p-q或较易分解的n" class="headerlink" title="一、普通解密(给出e,c，且已知p,q或较易分解的n)"></a><strong>一、普通解密(给出e,c，且已知p,q或较易分解的n)</strong></h2><p>可以直接根据RSA的基本原理写出脚本，对于较易分解的n可以使用factor网站在线质因数分解，也可以使用yafu工具进行分解。</p><p>基本解密过程：</p><p>phi(n)=(p-1)*(q-1) #计算欧拉函数</p><p>ed≡1 mod phi(n) #通过该表达式求密钥d</p><p>c**d≡m mod n #最后求得明文m</p><p>注意：计算出的m是一串数字，要得到真正意义上的明文，还得将其转化成字符。（不排除某些题目直接以m作为明文。）</p><h2 id="二、给出了n-p-q-dp-dq-c但未给出e"><a href="#二、给出了n-p-q-dp-dq-c但未给出e" class="headerlink" title="二、给出了n,p,q,dp,dq,c但未给出e"></a><strong>二、给出了n,p,q,dp,dq,c但未给出e</strong></h2><p>由于没有e我无法直接利用原理解出d，而使用中国剩余定理会因为p-1和q-1不互质而受到阻碍。</p><p>自己就推导了一个公式（因为看不懂别人写的解法）：</p><p>c**dp≡m mod p</p><p>(dp换成dq也是可以的，但对应的p就要换成q）</p><p>推导过程如下：</p><p>dp≡d mod p-1</p><p>d=dp+k*(p-1)#k为整数</p><p>c**d=c**(dp+k*(p-1))</p><p>c**d≡m mod n   </p><p>c**(dp+k*(p-1))≡m mod n</p><p>n=p*q</p><p>c**(dp+k*(p-1))≡m mod p</p><p>由费马小定理：a**(p-1)≡1 mod p</p><p>c**(p-1)≡1 mod p</p><p>c**k(p-1)≡1 mod p#k为整数时可由二项式定理证得，而当k为负数时，计算要先取逆元再-k次方，仍然可证。</p><p>c**dp≡m mod p</p><h2 id="三、-共模攻击（给出一个n和多组e-c）"><a href="#三、-共模攻击（给出一个n和多组e-c）" class="headerlink" title="三、 共模攻击（给出一个n和多组e,c）"></a><strong>三、 共模攻击（给出一个n和多组e,c）</strong></h2><p>寻找一组互质的e1,e2,再由欧几里得扩展算法可得：</p><p>e1*s1+e2*s2 = 1</p><p>之后想方设法拼凑表达式利用该条件</p><p>c1 = m**e1 mod n </p><p>c2 = m**e2 mod n</p><p>(c1**s1*c2**s2) mod n = ((m**e1 mod n)**s1*(m**e2 mod n)**s2)%n</p><p>(c1**s1*c2**s2) mod n = ((m**e1)**s1*(m**e2)**s2) mod n</p><p>(c1**s1*c2**s2) mod n = (m**(e1*s1+e2*s2)) mod n</p><p>c1**s1*c2**s2≡ m mod n </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">import</span> libnum<br>n=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入n： &quot;</span>))<br>e1=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入e1: &quot;</span>))<br>c1=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入c1: &quot;</span>))<br>e2=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入e2: &quot;</span>))<br>c2=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入c2: &quot;</span>))<br>s=gp.gcdext(e1,e2)<br>s1=s[<span class="hljs-number">1</span>]<br>s2=s[<span class="hljs-number">2</span>]<br><span class="hljs-keyword">if</span> s1&lt;<span class="hljs-number">0</span>:<br>    s1=-s1<br>    c1r=gp.invert(c1,n)<br>    m=<span class="hljs-built_in">pow</span>(c1r**s1*c2**s2,n)<br><span class="hljs-keyword">else</span>:<br>    s2=-s2<br>    c2r=gp.invert(c2,n)<br>    m=<span class="hljs-built_in">pow</span>(c1**s1*c2r**s2,n)<br>print(libnum.n2s(m))<br></code></pre></td></tr></table></figure><h2 id="四、-给出pem-enc-文件（或者其他将flag和解密信息放在文件中的题目）"><a href="#四、-给出pem-enc-文件（或者其他将flag和解密信息放在文件中的题目）" class="headerlink" title="四、 给出pem,enc 文件（或者其他将flag和解密信息放在文件中的题目）"></a><strong>四、 给出pem,enc 文件（或者其他将flag和解密信息放在文件中的题目）</strong></h2><p>1.</p><p>使用openssl工具（这个Linux自带）使用命令:</p><p><strong>openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem</strong></p><p>得到n,e,此时利用工具对n进行分解得到p,q。</p><p>再用 rsatool 生成私钥文件: private.pem <strong>python rsatool.py -o private.pem -e 65537 -p XXXXX -q XXXX</strong></p><p>最后用 private.pem 解密 flag.enc <strong>openssl rsautl -decrypt -in flag.enc -inkey private.pem</strong></p><p>可以得到答案。</p><p>2.</p><p>查看公钥文件也可以直接使用Python的一些库来完成操作。</p><p><code>from Crypto.PublicKey import RSA</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pub1=RSA.importKey(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./publickey1.pem&#x27;</span>).read())<br>n1= pub1.n<br>e1= pub1.e<br></code></pre></td></tr></table></figure><p>该操作可以直接读取公钥文件中的数据。</p><p>之后就是正常解密流程，得到，p,q,d。</p><p><code>import rsa</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">privatekey = rsa.PrivateKey(n,e,d,p,q)<br><span class="hljs-built_in">str</span>=f.read()<br>print(rsa.decrypt(<span class="hljs-built_in">str</span>,privatekey).decode())<br></code></pre></td></tr></table></figure><p>直接得到Privatekey,并志杰用其解密flag所在的文件，输出flag。</p><h2 id="五、-多组n-c，求m（低指数广播攻击）"><a href="#五、-多组n-c，求m（低指数广播攻击）" class="headerlink" title="五、  多组n,c，求m（低指数广播攻击）"></a><strong>五、  多组n,c，求m（低指数广播攻击）</strong></h2><p>对于多组，n,c,且已知e或e较小的情况。</p><p>利用中国剩余定理可以直接解出m**e,然后直接开根解得m。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>n1=<span class="hljs-number">0xe096219878f492bcdb2a2d03995521e7a65125733bae18e7d0005e35343fea3653698de60231d29b2d1b44a0b4ffd3183855b9042275f769e1702fa8843062df0938821db0258af40ab3cda8e54eb6ac826d545df91dfe76266cb01b1d6fad39e6ef13ce730c1c2395136b0bbdf22c6b0daba63701d71c6ae70d4e06935b9941</span><br>c1=<span class="hljs-number">0xff24bddc5a7b327535af92dba58c5d62a22d542e6ba1df6f91c98c7563d8e48e770fb623bfcc2f09ed49788293306ff709670b225da32ea134422d5e403b11c39ef6b144f96b2fe94b3aa136432ecea86a4069a4cb0b4d8570edb3fb5bb2cf0693184ef0c589887b012ebe6ea94e854a71a7eb768133d15e784e388976877db</span><br>n2=<span class="hljs-number">0xa36b15a395edf3e99927f658e22d5f4aefd83434972c96cca5242a1aaa517ad83739451269723092dd9e73c00682dd3bbd74a985546def88196119b6d57b397283bc7b8b6029916df84284bec1725f6e5d3d29042af685c508a58ab6fb4e5bfeb326ae49330e3f4426abc1860ca4412feb976ee571075a47b854c9a6f5f0ebff</span><br>c2=<span class="hljs-number">0x895f8283e2200bab1bf938ce3b5e42147b53a5178e436ea0b64a2380ba99776d5ba8046ef722858b20d9650ee68c09e905030f1634e0b32397b7b12236a5a301e5923a294ef1bdf16458f4fc8677370ce2ce3d0fd957da7466e5b104191d454455917147f3187b758c1c468db1b35514391e5b36bd1ac39e91bbb24fdbc07872</span><br>n3=<span class="hljs-number">0x9d4732db2539d1166dc6865670be11951bf49295bc8c472f34682a0fb7f2b3ba96dcfa1945c2e4685dfeae5255abe2ab3b7fb2282971bb16ce02d14082f71755e8a65c956e114336914a409a9f1158fb362a92c4e169fa3c460ea26fb5c6693447b14f1c3156a2d9308dd993d7ea708a00ad149fb77109d8a5f77de1703ba249</span><br>c3=<span class="hljs-number">0x3bead3d6760bff4de22562978d4722bb21ee4792ebdb32703b6df9ff5176e033e97ad8fc81467f4b3df7bd4e8bcae09462f3eca93a3da1cd9d7e8de3e464471fdd0b70112c1c738b0daa2a37a65331eaa8954b81b410f62a0280da32eb3e305782d5f774d814ca0adb13344687387cf72657dc21724bcf69da810d7635b99467</span><br>n1=<span class="hljs-built_in">int</span>(n1)<br>c1=<span class="hljs-built_in">int</span>(c1)<br>n2=<span class="hljs-built_in">int</span>(n2)<br>c2=<span class="hljs-built_in">int</span>(c2)<br>n3=<span class="hljs-built_in">int</span>(n3)<br>c3=<span class="hljs-built_in">int</span>(c3)<br>t1=gp.invert(n2*n3,n1)<br>t2=gp.invert(n1*n3,n2)<br>t3=gp.invert(n1*n2,n3)<br>weim=(c1*t1*n2*n3+c2*t2*n1*n3+c3*t3*n1*n2)%(n1*n2*n3)<br>m=gp.iroot(weim,<span class="hljs-number">3</span>)<br>print(m)<span class="hljs-comment">#这里先把m打印出来，可以得到类似mpz(....)这种数据，括号内就是所需的m数值，但这个带括号的数据不能直接使用long_to_bytes转化，所以这里先把m打出来然后直接复制到下面的函数里转化。</span><br>print(long_to_bytes(<span class="hljs-number">11667486319353623306221917311659938391432552876667393571592853766459303917362695551586161498975732393341</span>))<br></code></pre></td></tr></table></figure><p>但是如果已知e，也是可以直接爆破的，因为c≡m** e mod n,可以推出m**e=c+k *n,且一般k会大于零，因为根据rsa原理，我们是由m**e%n直接得到c，（因为如果c大于n，会有无数个解），所以可以直接把可能的k值带进去得到答案。</p><h2 id="六、给出n-e-dp-c的题目。"><a href="#六、给出n-e-dp-c的题目。" class="headerlink" title="六、给出n,e,dp,c的题目。"></a><strong>六、给出n,e,dp,c的题目。</strong></h2><p>d=dp+k1*(p-1)</p><p>de=1+k2*(p-1)*(q-1)</p><p>将这两个式子结合得：</p><p>e*dp+e*k1*(p-1)=k2*(p-1)+1</p><p>再将这个式子两边对（p-1）同时取余可得：</p><p>e*dp☰1 mod p-1</p><p>即：</p><p>e*dp=k*(p-1)+1</p><p>又因为dp&lt;p-1,k*(p-1)&lt;e*dp</p><p>所以e&gt;k;</p><p>接下来利用该表达式对k进行遍历就可以了，遍历范围(0,e)。</p>]]></content>
    
    
    <categories>
      
      <category>ctf-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ctf -rsa -aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElGamal</title>
    <link href="/2021/03/19/ElGamal/"/>
    <url>/2021/03/19/ElGamal/</url>
    
    <content type="html"><![CDATA[<h1 id="ElGamal"><a href="#ElGamal" class="headerlink" title="ElGamal"></a>ElGamal</h1><h2 id="ElGamal算法"><a href="#ElGamal算法" class="headerlink" title="ElGamal算法"></a>ElGamal算法</h2><p>此时有一个需被加密的消息x。</p><p><strong>密钥生成：</strong></p><p>随机取一个大素数p，并取Z<sub>p</sub><sup>*</sup>的一个本原元作为α，再从{2,…,p-2}中随机取一个数作为d,计算β ≡ α<sup>d</sup> mod p 。({d}为私钥，{p,α,β}为公钥。)</p><p><strong>加密：</strong></p><p>再次从{2,…p-2}中随机取一个数作为r,计算k<sub>r</sub>≡α<sup>r</sup> mod p。计算k<sub>m</sub>≡β<sup>r</sup> mod p。</p><p>计算y≡k<sub>m</sub>*x mod p，y就是加密出的密文。</p><p><strong>解密：</strong></p><p>计算x≡（k<sub>r</sub><sup>d</sup> )<sup>-1</sup>*y mod p 得出x。</p><h2 id="ElGamal协议"><a href="#ElGamal协议" class="headerlink" title="ElGamal协议"></a>ElGamal协议</h2><p>ElGamal协议是对ElGamal方案的正式定义。</p><p>为了方便描述，我们先假设有Alice和Bob这两个人。</p><p>为了保证消息的私密性，二人决定对传递的消息加密。</p><p>首先，Bob随机取一个大素数p，并取Z<sub>p</sub><sup>*</sup>的一个本原元作为α，在从{2,…,p-2}中随机取一个数字作为d,并计算β≡α<sup>d</sup> mod p。</p><p>Bob将p和α对外公开，并将（p,α,β）作为公钥k<sub>pub</sub>发送给Alice。</p><p>Alice从{2,…,p-2}中选择一个数作为r,计算k<sub>r</sub> ≡ α<sup>r</sup> mod p。计算k<sub>m</sub> ≡ β<sup>r</sup> mod p。</p><p>并将消息x（x的长度必须小于p）通过y≡x*k<sub>m</sub> mod p加密成y。最后，Alice将(k<sub>r</sub>,y)发送给Bob。</p><p>Bob通过k<sub>m</sub> ≡ k<sub>r</sub><sup>d</sup> mod p 计算出掩码密钥k<sub>m</sub>，而后再通过计算x ≡ y*k<sup>-1</sup> mod p得到x。</p><h2 id="ElGamal协议的验证"><a href="#ElGamal协议的验证" class="headerlink" title="ElGamal协议的验证"></a>ElGamal协议的验证</h2><p>Alice需加密的消息为x=11。</p><p>Bob生成一个素数P=13，取α=2。选择d=8，则可以计算出β=9。而后Bob将（p,α,β）作为k<sub>pub</sub>发送给Alice。</p><p>Alice选择r=5,计算出k<sub>r</sub>=α<sup>r</sup> ≡ 6 mod 13,再计算出k<sub>m</sub>=β<sup>r</sup> ≡ 3 mod 13,再对消息x进行加密，计算y=x*k<sub>m</sub> ≡ 7 mod 13。而后再将（k<sub>r</sub> , y)发送给Bob。</p><p>Bob通过k<sub>m</sub>=k<sub>r</sub><sup>d</sup> ≡ 3 mod 13,得到了k<sub>m</sub>，最后只要计算x=y*k<sub>m</sub><sup>-1</sup> ≡ 11 mod 13，便成功还原出了消息x。</p><h2 id="ElGamal加密和解密的代码的简单实现"><a href="#ElGamal加密和解密的代码的简单实现" class="headerlink" title="ElGamal加密和解密的代码的简单实现"></a>ElGamal加密和解密的代码的简单实现</h2><p>这里我直接将加密和解密的代码写在一起，方便验证其正确性。代码中的P是提前生成的大素数，af是Z<sub>p</sub><sup>*</sup>的一个本原元。（代码是用Python写的。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> bytes_to_long,long_to_bytes<br><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br>x=bytes_to_long(<span class="hljs-built_in">bytes</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input:&quot;</span>),encoding=<span class="hljs-string">&quot;utf-8&quot;</span>))<br>p=<span class="hljs-number">25123340539613169448341086263083665422339746291241104014172083032815449631995806048303663356814273919781597336198663028438720363603452541021888997965977983</span><br>af=<span class="hljs-number">2</span><br>d=<span class="hljs-number">5</span><span class="hljs-comment">#从零到p-2中取随机取一个数，这里直接取5</span><br>b=<span class="hljs-built_in">pow</span>(af,d,p)<br>r=<span class="hljs-number">67</span><span class="hljs-comment">#从零到p-2中随机去一个数，这里取67</span><br>km=b**r%p<span class="hljs-comment">#计算加密的密钥</span><br>y=km*x%p<span class="hljs-comment">#得出密文</span><br>print(<span class="hljs-string">&quot;密文为：&quot;</span>,y)<br><span class="hljs-comment">#*************</span><br><span class="hljs-comment">#下面这部分是解密代码</span><br><span class="hljs-comment">#*************</span><br>kr=<span class="hljs-built_in">pow</span>(af,r,p)<span class="hljs-comment">#这里才计算kr是因为只有解密时才需要kr</span><br>km=<span class="hljs-built_in">pow</span>(kr,d,p)<span class="hljs-comment">#计算解密所需密钥</span><br>k=gp.invert(km,p)<span class="hljs-comment">#计算解密的密钥的逆元</span><br>dx=y*k%p<br>print(<span class="hljs-string">&quot;明文为：&quot;</span>,long_to_bytes(dx))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ElGaml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020BJDasa</title>
    <link href="/2021/03/19/asa/"/>
    <url>/2021/03/19/asa/</url>
    
    <content type="html"><![CDATA[<h1 id="2020BJDasa"><a href="#2020BJDasa" class="headerlink" title="2020BJDasa"></a>2020BJDasa</h1><p>可以发现两个n公用了一个p,那么求取两个n的最大公因数就可以得到p,这样一来两个n就都可以被分解了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>n1=<span class="hljs-number">0x661d752110bcc6ee5ca33edaf244716cccce6400dfdbfd84ce6ae2d8fbbeb2f61584da7668768403b6135e7810eae9d4d8e044935f8680de5324c3fc0f9bffb01812f9d2ac9055ee8dbd17b90c5a60cb7595a82f24a075d951db3b7f913b8543ecd52b8c8464ce348c3970d511ae911e814f9ca33b8412db2730e61820f5de47</span><br>p=<span class="hljs-number">9540203717217880059997385799331301649727503984010337568404427747385824530958536656147747848448822264268428226235860927158082497191830274046098671199542207</span><br>c1=<span class="hljs-number">0xd7931796fa39cfa37c0b621c01175904206dff1d74a28369dcd6517957ed76c5eb7d4934cbeb902119f9215f9ae7926debe3abe856244b45dbb4caaa2b93dbb79a3ca1a9813e1466c49fe3c03e5462811afbf3f40ff79927f9fe3681b7f3cef34466b9a736512f4931b5026eefacbae9be6e408085a7a636c514574c3b22ffe</span><br>q=n1//p<br>phi=(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>e=<span class="hljs-number">65537</span><br>d=gp.invert(e,phi)<br>m=<span class="hljs-built_in">pow</span>(c1,d,n1)<br>print(long_to_bytes(m))<br><span class="hljs-comment">#key=b&#x27;\x89)\xef\x12\xa1\x7f\x14[\xc9\xb4\x8a\xfa,\x88\xa2\xef&#x27;</span><br></code></pre></td></tr></table></figure><p>同理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>p=<span class="hljs-number">9540203717217880059997385799331301649727503984010337568404427747385824530958536656147747848448822264268428226235860927158082497191830274046098671199542207</span><br>n2=<span class="hljs-number">0x9f159326c907441326c88d17eae1c6e8aaea23922c5e628a585294e379e9245644f9c249c57f54a2b83921b4adc988fecc90c00feb6936d9be1f3a5ffae951b74ffbc6fc7aa11743e4ca179a937392dacf931e820d1d83016562ff608e8c59ef7310654a09bbba4a0129f71dcb61bd9bef073bbb93bfcac4a7a2e81156dbb32d</span><br>c2=<span class="hljs-number">0x6240740d41a539a88634726cf0a791a87e02419c3c3e00dff62eba59e81a93fd04a59109e57f64fc375b9a321583b6fa133317eb5c4e6eb1e6f6d9a0b4ae6ff0c54423718811f7956cd63b7bf9c7f8e29f48dad8f05b63b71d6c5112d91864adba0d6bb342c67aee39ccd5e2a6928a8e4ab2248d29a0c990bae821b31b39b1f3</span><br>q=n2//p<br>phi=(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>e=<span class="hljs-number">65537</span><br>d=gp.invert(e,phi)<br>m=<span class="hljs-built_in">pow</span>(c2,d,n2)<br>print(long_to_bytes(m))<br><span class="hljs-comment">#iv=b&#x27;\xf5\xf6\xa8\x8b\x08U\xedG\xe0\xdew\x1c\xaf&lt;\xb2&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>iv和key都已求出，进行最后一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> binascii<br>key=<span class="hljs-string">b&#x27;\x89)\xef\x12\xa1\x7f\x14[\xc9\xb4\x8a\xfa,\x88\xa2\xef&#x27;</span><br>iv=<span class="hljs-string">b&#x27;\xf5\xf6\xa8\x8b\x08U\xedG\xe0\xdew\x1c\xaf&lt;\xb2&gt;&#x27;</span><br>aa = AES.new(key, AES.MODE_CBC, iv)<br>data = <span class="hljs-string">&#x27;f8559d671b720cd336f2d8518ad6eac8c405585158dfde74ced376ba42d9fe984d519dc185030ddec7b4dc240fd90fa8&#x27;</span><br>data = binascii.a2b_hex(data)<br>data = aa.decrypt(data)<br>print(data)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ctf -rsa -aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
