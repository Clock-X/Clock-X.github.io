<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rsa初期</title>
    <link href="/2021/03/19/RSA%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%EF%BC%88%E5%88%9D%E6%9C%9F%EF%BC%89/"/>
    <url>/2021/03/19/RSA%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%EF%BC%88%E5%88%9D%E6%9C%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA常见题型"><a href="#RSA常见题型" class="headerlink" title="RSA常见题型"></a>RSA常见题型</h1><h2 id="一、普通解密-给出e-c，且已知p-q或较易分解的n"><a href="#一、普通解密-给出e-c，且已知p-q或较易分解的n" class="headerlink" title="一、普通解密(给出e,c，且已知p,q或较易分解的n)"></a><strong>一、普通解密(给出e,c，且已知p,q或较易分解的n)</strong></h2><p>可以直接根据RSA的基本原理写出脚本，对于较易分解的n可以使用factor网站在线质因数分解，也可以使用yafu工具进行分解。</p><p>基本解密过程：</p><p>phi(n)=(p-1)*(q-1) #计算欧拉函数</p><p>ed≡1 mod phi(n) #通过该表达式求密钥d</p><p>c**d≡m mod n #最后求得明文m</p><p>注意：计算出的m是一串数字，要得到真正意义上的明文，还得将其转化成字符。（不排除某些题目直接以m作为明文。）</p><h2 id="二、给出了n-p-q-dp-dq-c但未给出e"><a href="#二、给出了n-p-q-dp-dq-c但未给出e" class="headerlink" title="二、给出了n,p,q,dp,dq,c但未给出e"></a><strong>二、给出了n,p,q,dp,dq,c但未给出e</strong></h2><p>由于没有e我无法直接利用原理解出d，而使用中国剩余定理会因为p-1和q-1不互质而受到阻碍。</p><p>自己就推导了一个公式（因为看不懂别人写的解法）：</p><p>c**dp≡m mod p</p><p>(dp换成dq也是可以的，但对应的p就要换成q）</p><p>推导过程如下：</p><p>dp≡d mod p-1</p><p>d=dp+k*(p-1)#k为整数</p><p>c**d=c**(dp+k*(p-1))</p><p>c**d≡m mod n   </p><p>c**(dp+k*(p-1))≡m mod n</p><p>n=p*q</p><p>c**(dp+k*(p-1))≡m mod p</p><p>由费马小定理：a**(p-1)≡1 mod p</p><p>c**(p-1)≡1 mod p</p><p>c**k(p-1)≡1 mod p#k为整数时可由二项式定理证得，而当k为负数时，计算要先取逆元再-k次方，仍然可证。</p><p>c**dp≡m mod p</p><h2 id="三、-共模攻击（给出一个n和多组e-c）"><a href="#三、-共模攻击（给出一个n和多组e-c）" class="headerlink" title="三、 共模攻击（给出一个n和多组e,c）"></a><strong>三、 共模攻击（给出一个n和多组e,c）</strong></h2><p>寻找一组互质的e1,e2,再由欧几里得扩展算法可得：</p><p>e1*s1+e2*s2 = 1</p><p>之后想方设法拼凑表达式利用该条件</p><p>c1 = m**e1 mod n </p><p>c2 = m**e2 mod n</p><p>(c1**s1*c2**s2) mod n = ((m**e1 mod n)**s1*(m**e2 mod n)**s2)%n</p><p>(c1**s1*c2**s2) mod n = ((m**e1)**s1*(m**e2)**s2) mod n</p><p>(c1**s1*c2**s2) mod n = (m**(e1*s1+e2*s2)) mod n</p><p>c1**s1*c2**s2≡ m mod n </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">import</span> libnum<br>n=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入n： &quot;</span>))<br>e1=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入e1: &quot;</span>))<br>c1=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入c1: &quot;</span>))<br>e2=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入e2: &quot;</span>))<br>c2=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入c2: &quot;</span>))<br>s=gp.gcdext(e1,e2)<br>s1=s[<span class="hljs-number">1</span>]<br>s2=s[<span class="hljs-number">2</span>]<br><span class="hljs-keyword">if</span> s1&lt;<span class="hljs-number">0</span>:<br>    s1=-s1<br>    c1r=gp.invert(c1,n)<br>    m=<span class="hljs-built_in">pow</span>(c1r**s1*c2**s2,n)<br><span class="hljs-keyword">else</span>:<br>    s2=-s2<br>    c2r=gp.invert(c2,n)<br>    m=<span class="hljs-built_in">pow</span>(c1**s1*c2r**s2,n)<br>print(libnum.n2s(m))<br></code></pre></td></tr></table></figure><h2 id="四、-给出pem-enc-文件（或者其他将flag和解密信息放在文件中的题目）"><a href="#四、-给出pem-enc-文件（或者其他将flag和解密信息放在文件中的题目）" class="headerlink" title="四、 给出pem,enc 文件（或者其他将flag和解密信息放在文件中的题目）"></a><strong>四、 给出pem,enc 文件（或者其他将flag和解密信息放在文件中的题目）</strong></h2><p>1.</p><p>使用openssl工具（这个Linux自带）使用命令:</p><p><strong>openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem</strong></p><p>得到n,e,此时利用工具对n进行分解得到p,q。</p><p>再用 rsatool 生成私钥文件: private.pem <strong>python rsatool.py -o private.pem -e 65537 -p XXXXX -q XXXX</strong></p><p>最后用 private.pem 解密 flag.enc <strong>openssl rsautl -decrypt -in flag.enc -inkey private.pem</strong></p><p>可以得到答案。</p><p>2.</p><p>查看公钥文件也可以直接使用Python的一些库来完成操作。</p><p><code>from Crypto.PublicKey import RSA</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pub1=RSA.importKey(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./publickey1.pem&#x27;</span>).read())<br>n1= pub1.n<br>e1= pub1.e<br></code></pre></td></tr></table></figure><p>该操作可以直接读取公钥文件中的数据。</p><p>之后就是正常解密流程，得到，p,q,d。</p><p><code>import rsa</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">privatekey = rsa.PrivateKey(n,e,d,p,q)<br><span class="hljs-built_in">str</span>=f.read()<br>print(rsa.decrypt(<span class="hljs-built_in">str</span>,privatekey).decode())<br></code></pre></td></tr></table></figure><p>直接得到Privatekey,并志杰用其解密flag所在的文件，输出flag。</p><h2 id="五、-多组n-c，求m（低指数广播攻击）"><a href="#五、-多组n-c，求m（低指数广播攻击）" class="headerlink" title="五、  多组n,c，求m（低指数广播攻击）"></a><strong>五、  多组n,c，求m（低指数广播攻击）</strong></h2><p>对于多组，n,c,且已知e或e较小的情况。</p><p>利用中国剩余定理可以直接解出m**e,然后直接开根解得m。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>n1=<span class="hljs-number">0xe096219878f492bcdb2a2d03995521e7a65125733bae18e7d0005e35343fea3653698de60231d29b2d1b44a0b4ffd3183855b9042275f769e1702fa8843062df0938821db0258af40ab3cda8e54eb6ac826d545df91dfe76266cb01b1d6fad39e6ef13ce730c1c2395136b0bbdf22c6b0daba63701d71c6ae70d4e06935b9941</span><br>c1=<span class="hljs-number">0xff24bddc5a7b327535af92dba58c5d62a22d542e6ba1df6f91c98c7563d8e48e770fb623bfcc2f09ed49788293306ff709670b225da32ea134422d5e403b11c39ef6b144f96b2fe94b3aa136432ecea86a4069a4cb0b4d8570edb3fb5bb2cf0693184ef0c589887b012ebe6ea94e854a71a7eb768133d15e784e388976877db</span><br>n2=<span class="hljs-number">0xa36b15a395edf3e99927f658e22d5f4aefd83434972c96cca5242a1aaa517ad83739451269723092dd9e73c00682dd3bbd74a985546def88196119b6d57b397283bc7b8b6029916df84284bec1725f6e5d3d29042af685c508a58ab6fb4e5bfeb326ae49330e3f4426abc1860ca4412feb976ee571075a47b854c9a6f5f0ebff</span><br>c2=<span class="hljs-number">0x895f8283e2200bab1bf938ce3b5e42147b53a5178e436ea0b64a2380ba99776d5ba8046ef722858b20d9650ee68c09e905030f1634e0b32397b7b12236a5a301e5923a294ef1bdf16458f4fc8677370ce2ce3d0fd957da7466e5b104191d454455917147f3187b758c1c468db1b35514391e5b36bd1ac39e91bbb24fdbc07872</span><br>n3=<span class="hljs-number">0x9d4732db2539d1166dc6865670be11951bf49295bc8c472f34682a0fb7f2b3ba96dcfa1945c2e4685dfeae5255abe2ab3b7fb2282971bb16ce02d14082f71755e8a65c956e114336914a409a9f1158fb362a92c4e169fa3c460ea26fb5c6693447b14f1c3156a2d9308dd993d7ea708a00ad149fb77109d8a5f77de1703ba249</span><br>c3=<span class="hljs-number">0x3bead3d6760bff4de22562978d4722bb21ee4792ebdb32703b6df9ff5176e033e97ad8fc81467f4b3df7bd4e8bcae09462f3eca93a3da1cd9d7e8de3e464471fdd0b70112c1c738b0daa2a37a65331eaa8954b81b410f62a0280da32eb3e305782d5f774d814ca0adb13344687387cf72657dc21724bcf69da810d7635b99467</span><br>n1=<span class="hljs-built_in">int</span>(n1)<br>c1=<span class="hljs-built_in">int</span>(c1)<br>n2=<span class="hljs-built_in">int</span>(n2)<br>c2=<span class="hljs-built_in">int</span>(c2)<br>n3=<span class="hljs-built_in">int</span>(n3)<br>c3=<span class="hljs-built_in">int</span>(c3)<br>t1=gp.invert(n2*n3,n1)<br>t2=gp.invert(n1*n3,n2)<br>t3=gp.invert(n1*n2,n3)<br>weim=(c1*t1*n2*n3+c2*t2*n1*n3+c3*t3*n1*n2)%(n1*n2*n3)<br>m=gp.iroot(weim,<span class="hljs-number">3</span>)<br>print(m)<span class="hljs-comment">#这里先把m打印出来，可以得到类似mpz(....)这种数据，括号内就是所需的m数值，但这个带括号的数据不能直接使用long_to_bytes转化，所以这里先把m打出来然后直接复制到下面的函数里转化。</span><br>print(long_to_bytes(<span class="hljs-number">11667486319353623306221917311659938391432552876667393571592853766459303917362695551586161498975732393341</span>))<br></code></pre></td></tr></table></figure><p>但是如果已知e，也是可以直接爆破的，因为c≡m** e mod n,可以推出m**e=c+k *n,且一般k会大于零，因为根据rsa原理，我们是由m**e%n直接得到c，（因为如果c大于n，会有无数个解），所以可以直接把可能的k值带进去得到答案。</p><h1 id="六、给出n-e-dp-c的题目。"><a href="#六、给出n-e-dp-c的题目。" class="headerlink" title="六、给出n,e,dp,c的题目。"></a><strong>六、给出n,e,dp,c的题目。</strong></h1><p>d=dp+k1*(p-1)</p><p>de=1+k2*(p-1)*(q-1)</p><p>将这两个式子结合得：</p><p>e*dp+e*k1*(p-1)=k2*(p-1)+1</p><p>再将这个式子两边对（p-1）同时取余可得：</p><p>e*dp☰1 mod p-1</p><p>即：</p><p>e*dp=k*(p-1)+1</p><p>又因为dp&lt;p-1,k*(p-1)&lt;e*dp</p><p>所以e&gt;k;</p><p>接下来利用该表达式对k进行遍历就可以了，遍历范围(0,e)。</p><h1 id="七、给出p的高位"><a href="#七、给出p的高位" class="headerlink" title="七、给出p的高位"></a>七、给出p的高位</h1><p>wiki上的代码直接搬过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sage">from sage.all import *<br>import binascii<br>n &#x3D; 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f<br>p4 &#x3D;0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde1362693<br>cipher &#x3D; 0xf11e932fa420790ca3976468dc4df1e6b20519ebfdc427c09e06940e1ef0ca566d41714dc1545ddbdcae626eb51c7fa52608384a36a2a021960d71023b5d0f63e6b38b46ac945ddafea42f01d24cc33ce16825df7aa61395d13617ae619dca2df15b5963c77d6ededf2fe06fd36ae8c5ce0e3c21d72f2d7f20cd9a8696fbb628df29299a6b836c418cbfe91e2b5be74bdfdb4efdd1b33f57ebb72c5246d5dce635529f1f69634d565a631e950d4a34a02281cbed177b5a624932c2bc02f0c8fd9afd332ccf93af5048f02b8bd72213d6a52930b0faa0926973883136d8530b8acf732aede8bb71cb187691ebd93a0ea8aeec7f82d0b8b74bcf010c8a38a1fa8<br>e2 &#x3D; 0xf93b<br>pbits &#x3D; 1024<br>kbits &#x3D; pbits - p4.nbits()<br>print p4.nbits()<br>p4 &#x3D; p4 &lt;&lt; kbits<br>PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))<br>f &#x3D; x + p4<br>roots &#x3D; f.small_roots(X&#x3D;2^kbits, beta&#x3D;0.4)<br>if roots:<br>    p &#x3D; p4+int(roots[0])<br>    print &quot;p: &quot;, hex(int(p))<br>    assert n % p &#x3D;&#x3D; 0<br>    q &#x3D; n&#x2F;int(p)<br>    print &quot;q: &quot;, hex(int(q))<br>    print gcd(p,q)<br>    phin &#x3D; (p-1)*(q-1)<br>    print gcd(e2,phin)<br>    d &#x3D; inverse_mod(e2,phin)<br>    flag &#x3D; pow(cipher,d,n)<br>    flag &#x3D; hex(int(flag))[2:-1]<br>    print binascii.unhexlify(flag)<br></code></pre></td></tr></table></figure><h1 id="八、e过大导致d可能很小，winnerattack"><a href="#八、e过大导致d可能很小，winnerattack" class="headerlink" title="八、e过大导致d可能很小，winnerattack"></a>八、e过大导致d可能很小，winnerattack</h1><p>原理涉及到连分数这些概念</p><p>代码直接搬过来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span>(<span class="hljs-params">x, y</span>):</span>  <span class="hljs-comment"># 使用辗转相处将分数 x/y 转为连分数的形式</span><br>    res = []<br>    <span class="hljs-keyword">while</span> y:<br>        res.append(x // y)<br>        x, y = y, x % y<br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">continued_fraction</span>(<span class="hljs-params">sub_res</span>):</span><br>    numerator, denominator = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sub_res[::-<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 从sublist的后面往前循环</span><br>        denominator, numerator = numerator, i * numerator + denominator<br>    <span class="hljs-keyword">return</span> denominator, numerator  <span class="hljs-comment"># 得到渐进分数的分母和分子，并返回</span><br><br><br><span class="hljs-comment"># 求解每个渐进分数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_fraction</span>(<span class="hljs-params">x, y</span>):</span><br>    res = transform(x, y)<br>    res = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(continued_fraction, (res[<span class="hljs-number">0</span>:i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(res)))))  <span class="hljs-comment"># 将连分数的结果逐一截取以求渐进分数</span><br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pq</span>(<span class="hljs-params">a, b, c</span>):</span>  <span class="hljs-comment"># 由p+q和pq的值通过维达定理来求解p和q</span><br>    par = gmpy2.isqrt(b * b - <span class="hljs-number">4</span> * a * c)  <span class="hljs-comment"># 由上述可得，开根号一定是整数，因为有解</span><br>    x1, x2 = (-b + par) // (<span class="hljs-number">2</span> * a), (-b - par) // (<span class="hljs-number">2</span> * a)<br>    <span class="hljs-keyword">return</span> x1, x2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wienerAttack</span>(<span class="hljs-params">e, n</span>):</span><br>    <span class="hljs-keyword">for</span> (d, k) <span class="hljs-keyword">in</span> sub_fraction(e, n):  <span class="hljs-comment"># 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数</span><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 可能会出现连分数的第一个为0的情况，排除</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> (e * d - <span class="hljs-number">1</span>) % k != <span class="hljs-number">0</span>:  <span class="hljs-comment"># ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)</span><br>            <span class="hljs-keyword">continue</span><br><br>        phi = (e * d - <span class="hljs-number">1</span>) // k  <span class="hljs-comment"># 这个结果就是 φ(n)</span><br>        px, qy = get_pq(<span class="hljs-number">1</span>, n - phi + <span class="hljs-number">1</span>, n)<br>        <span class="hljs-keyword">if</span> px * qy == n:<br>            p, q = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(px)), <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(qy))  <span class="hljs-comment"># 可能会得到两个负数，负负得正未尝不会出现</span><br>            d = gmpy2.invert(e, (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>))  <span class="hljs-comment"># 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d</span><br>            <span class="hljs-keyword">return</span> d<br>    print(<span class="hljs-string">&quot;该方法不适用&quot;</span>)<br><br><br>e = <span class="hljs-number">14058695417015334071588010346586749790539913287499707802938898719199384604316115908373997739604466972535533733290829894940306314501336291780396644520926473</span><br>n = <span class="hljs-number">33608051123287760315508423639768587307044110783252538766412788814888567164438282747809126528707329215122915093543085008547092423658991866313471837522758159</span><br>d = wienerAttack(e, n)<br>print(<span class="hljs-string">&quot;d=&quot;</span>, d)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">emmmm干脆直接照搬过来吧</span><br><span class="hljs-string">原文链接：https: // blog.csdn.net / rreally / article / details / 111092579</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ctf -rsa -aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElGamal</title>
    <link href="/2021/03/19/ElGamal/"/>
    <url>/2021/03/19/ElGamal/</url>
    
    <content type="html"><![CDATA[<h1 id="ElGamal"><a href="#ElGamal" class="headerlink" title="ElGamal"></a>ElGamal</h1><h2 id="ElGamal算法"><a href="#ElGamal算法" class="headerlink" title="ElGamal算法"></a>ElGamal算法</h2><p>此时有一个需被加密的消息x。</p><p><strong>密钥生成：</strong></p><p>随机取一个大素数p，并取Z<sub>p</sub><sup>*</sup>的一个本原元作为α，再从{2,…,p-2}中随机取一个数作为d,计算β ≡ α<sup>d</sup> mod p 。({d}为私钥，{p,α,β}为公钥。)</p><p><strong>加密：</strong></p><p>再次从{2,…p-2}中随机取一个数作为r,计算k<sub>r</sub>≡α<sup>r</sup> mod p。计算k<sub>m</sub>≡β<sup>r</sup> mod p。</p><p>计算y≡k<sub>m</sub>*x mod p，y就是加密出的密文。</p><p><strong>解密：</strong></p><p>计算x≡（k<sub>r</sub><sup>d</sup> )<sup>-1</sup>*y mod p 得出x。</p><h2 id="ElGamal协议"><a href="#ElGamal协议" class="headerlink" title="ElGamal协议"></a>ElGamal协议</h2><p>ElGamal协议是对ElGamal方案的正式定义。</p><p>为了方便描述，我们先假设有Alice和Bob这两个人。</p><p>为了保证消息的私密性，二人决定对传递的消息加密。</p><p>首先，Bob随机取一个大素数p，并取Z<sub>p</sub><sup>*</sup>的一个本原元作为α，在从{2,…,p-2}中随机取一个数字作为d,并计算β≡α<sup>d</sup> mod p。</p><p>Bob将p和α对外公开，并将（p,α,β）作为公钥k<sub>pub</sub>发送给Alice。</p><p>Alice从{2,…,p-2}中选择一个数作为r,计算k<sub>r</sub> ≡ α<sup>r</sup> mod p。计算k<sub>m</sub> ≡ β<sup>r</sup> mod p。</p><p>并将消息x（x的长度必须小于p）通过y≡x*k<sub>m</sub> mod p加密成y。最后，Alice将(k<sub>r</sub>,y)发送给Bob。</p><p>Bob通过k<sub>m</sub> ≡ k<sub>r</sub><sup>d</sup> mod p 计算出掩码密钥k<sub>m</sub>，而后再通过计算x ≡ y*k<sup>-1</sup> mod p得到x。</p><h2 id="ElGamal协议的验证"><a href="#ElGamal协议的验证" class="headerlink" title="ElGamal协议的验证"></a>ElGamal协议的验证</h2><p>Alice需加密的消息为x=11。</p><p>Bob生成一个素数P=13，取α=2。选择d=8，则可以计算出β=9。而后Bob将（p,α,β）作为k<sub>pub</sub>发送给Alice。</p><p>Alice选择r=5,计算出k<sub>r</sub>=α<sup>r</sup> ≡ 6 mod 13,再计算出k<sub>m</sub>=β<sup>r</sup> ≡ 3 mod 13,再对消息x进行加密，计算y=x*k<sub>m</sub> ≡ 7 mod 13。而后再将（k<sub>r</sub> , y)发送给Bob。</p><p>Bob通过k<sub>m</sub>=k<sub>r</sub><sup>d</sup> ≡ 3 mod 13,得到了k<sub>m</sub>，最后只要计算x=y*k<sub>m</sub><sup>-1</sup> ≡ 11 mod 13，便成功还原出了消息x。</p><h2 id="ElGamal加密和解密的代码的简单实现"><a href="#ElGamal加密和解密的代码的简单实现" class="headerlink" title="ElGamal加密和解密的代码的简单实现"></a>ElGamal加密和解密的代码的简单实现</h2><p>这里我直接将加密和解密的代码写在一起，方便验证其正确性。代码中的P是提前生成的大素数，af是Z<sub>p</sub><sup>*</sup>的一个本原元。（代码是用Python写的。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> bytes_to_long,long_to_bytes<br><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br>x=bytes_to_long(<span class="hljs-built_in">bytes</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input:&quot;</span>),encoding=<span class="hljs-string">&quot;utf-8&quot;</span>))<br>p=<span class="hljs-number">25123340539613169448341086263083665422339746291241104014172083032815449631995806048303663356814273919781597336198663028438720363603452541021888997965977983</span><br>af=<span class="hljs-number">2</span><br>d=<span class="hljs-number">5</span><span class="hljs-comment">#从零到p-2中取随机取一个数，这里直接取5</span><br>b=<span class="hljs-built_in">pow</span>(af,d,p)<br>r=<span class="hljs-number">67</span><span class="hljs-comment">#从零到p-2中随机去一个数，这里取67</span><br>km=b**r%p<span class="hljs-comment">#计算加密的密钥</span><br>y=km*x%p<span class="hljs-comment">#得出密文</span><br>print(<span class="hljs-string">&quot;密文为：&quot;</span>,y)<br><span class="hljs-comment">#*************</span><br><span class="hljs-comment">#下面这部分是解密代码</span><br><span class="hljs-comment">#*************</span><br>kr=<span class="hljs-built_in">pow</span>(af,r,p)<span class="hljs-comment">#这里才计算kr是因为只有解密时才需要kr</span><br>km=<span class="hljs-built_in">pow</span>(kr,d,p)<span class="hljs-comment">#计算解密所需密钥</span><br>k=gp.invert(km,p)<span class="hljs-comment">#计算解密的密钥的逆元</span><br>dx=y*k%p<br>print(<span class="hljs-string">&quot;明文为：&quot;</span>,long_to_bytes(dx))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>knowledge-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ElGaml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020BJDasa</title>
    <link href="/2021/03/19/asa/"/>
    <url>/2021/03/19/asa/</url>
    
    <content type="html"><![CDATA[<h1 id="2020BJDasa"><a href="#2020BJDasa" class="headerlink" title="2020BJDasa"></a>2020BJDasa</h1><p>可以发现两个n公用了一个p,那么求取两个n的最大公因数就可以得到p,这样一来两个n就都可以被分解了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>n1=<span class="hljs-number">0x661d752110bcc6ee5ca33edaf244716cccce6400dfdbfd84ce6ae2d8fbbeb2f61584da7668768403b6135e7810eae9d4d8e044935f8680de5324c3fc0f9bffb01812f9d2ac9055ee8dbd17b90c5a60cb7595a82f24a075d951db3b7f913b8543ecd52b8c8464ce348c3970d511ae911e814f9ca33b8412db2730e61820f5de47</span><br>p=<span class="hljs-number">9540203717217880059997385799331301649727503984010337568404427747385824530958536656147747848448822264268428226235860927158082497191830274046098671199542207</span><br>c1=<span class="hljs-number">0xd7931796fa39cfa37c0b621c01175904206dff1d74a28369dcd6517957ed76c5eb7d4934cbeb902119f9215f9ae7926debe3abe856244b45dbb4caaa2b93dbb79a3ca1a9813e1466c49fe3c03e5462811afbf3f40ff79927f9fe3681b7f3cef34466b9a736512f4931b5026eefacbae9be6e408085a7a636c514574c3b22ffe</span><br>q=n1//p<br>phi=(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>e=<span class="hljs-number">65537</span><br>d=gp.invert(e,phi)<br>m=<span class="hljs-built_in">pow</span>(c1,d,n1)<br>print(long_to_bytes(m))<br><span class="hljs-comment">#key=b&#x27;\x89)\xef\x12\xa1\x7f\x14[\xc9\xb4\x8a\xfa,\x88\xa2\xef&#x27;</span><br></code></pre></td></tr></table></figure><p>同理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>p=<span class="hljs-number">9540203717217880059997385799331301649727503984010337568404427747385824530958536656147747848448822264268428226235860927158082497191830274046098671199542207</span><br>n2=<span class="hljs-number">0x9f159326c907441326c88d17eae1c6e8aaea23922c5e628a585294e379e9245644f9c249c57f54a2b83921b4adc988fecc90c00feb6936d9be1f3a5ffae951b74ffbc6fc7aa11743e4ca179a937392dacf931e820d1d83016562ff608e8c59ef7310654a09bbba4a0129f71dcb61bd9bef073bbb93bfcac4a7a2e81156dbb32d</span><br>c2=<span class="hljs-number">0x6240740d41a539a88634726cf0a791a87e02419c3c3e00dff62eba59e81a93fd04a59109e57f64fc375b9a321583b6fa133317eb5c4e6eb1e6f6d9a0b4ae6ff0c54423718811f7956cd63b7bf9c7f8e29f48dad8f05b63b71d6c5112d91864adba0d6bb342c67aee39ccd5e2a6928a8e4ab2248d29a0c990bae821b31b39b1f3</span><br>q=n2//p<br>phi=(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>e=<span class="hljs-number">65537</span><br>d=gp.invert(e,phi)<br>m=<span class="hljs-built_in">pow</span>(c2,d,n2)<br>print(long_to_bytes(m))<br><span class="hljs-comment">#iv=b&#x27;\xf5\xf6\xa8\x8b\x08U\xedG\xe0\xdew\x1c\xaf&lt;\xb2&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>iv和key都已求出，进行最后一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> binascii<br>key=<span class="hljs-string">b&#x27;\x89)\xef\x12\xa1\x7f\x14[\xc9\xb4\x8a\xfa,\x88\xa2\xef&#x27;</span><br>iv=<span class="hljs-string">b&#x27;\xf5\xf6\xa8\x8b\x08U\xedG\xe0\xdew\x1c\xaf&lt;\xb2&gt;&#x27;</span><br>aa = AES.new(key, AES.MODE_CBC, iv)<br>data = <span class="hljs-string">&#x27;f8559d671b720cd336f2d8518ad6eac8c405585158dfde74ced376ba42d9fe984d519dc185030ddec7b4dc240fd90fa8&#x27;</span><br>data = binascii.a2b_hex(data)<br>data = aa.decrypt(data)<br>print(data)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ctf-crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Crypto -ctf -rsa -aes</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
